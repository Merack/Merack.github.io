{
    "version": "https://jsonfeed.org/version/1",
    "title": "Merack&#x27;s Home",
    "description": "",
    "home_page_url": "https://blog.merack.top",
    "feed_url": "https://blog.merack.top/feed.json",
    "user_comment": "",
    "author": {
        "name": "Merack"
    },
    "items": [
        {
            "id": "https://blog.merack.top/shelljiao-ben-linuxding-shi-bei-fen-bing-tong-guo-webdavshang-chuan-zhi-jian-guo-yun.html",
            "url": "https://blog.merack.top/shelljiao-ben-linuxding-shi-bei-fen-bing-tong-guo-webdavshang-chuan-zhi-jian-guo-yun.html",
            "title": "shell脚本 - Linux定时备份并通过WebDAV上传至坚果云",
            "summary": "为了保证数据的安全与完整, 对Linux上的重要数据和配置进行备份是很必要的, 备份文件最好在本地存一份, 上传到云服务一份. 我的服务器上的数据比较少, 打包压缩完大概是100M左右, 思来想去打算用WebDAV的方式传到坚果云. 坚果云存储空间不限量但是普通用户每月的上传流量限制是1G, 对我来说是绰绰有余了. 保存以下sh代码,&hellip;",
            "content_html": "<p>为了保证数据的安全与完整, 对Linux上的重要数据和配置进行备份是很必要的, 备份文件最好在本地存一份, 上传到云服务一份. 我的服务器上的数据比较少, 打包压缩完大概是100M左右, 思来想去打算用WebDAV的方式传到坚果云. <a href=\"https://www.jianguoyun.com/\">坚果云</a>存储空间不限量但是普通用户每月的上传流量限制是1G, 对我来说是绰绰有余了.</p>\n<h2>准备</h2>\n<ol>\n<li>坚果云账号, 在网页端右上角 账户信息 -&gt; <a href=\"https://www.jianguoyun.com/d/home#/safety\">安全选项</a> 里添加一个应用, 记住生成的WebDAV密码, 账户, WebDAV服务器地址</li>\n<li>根据 <a href=\"https://www.cnblogs.com/misterh/p/9830905.html\">这篇文章</a>(https://www.cnblogs.com/misterh/p/9830905.html) 安装cadaver, 并配置非交互式登录</li>\n</ol>\n<h2>代码</h2>\n<p>保存以下sh代码, 根据你的情况修改directories, db_user, db_password, db_names, backup_file等变量</p>\n<pre class=\"EnlighterJSRAW\" data-enlighter-language=\"bash\">#!/bin/bash\n\n# 定义要备份的目录\ndirectories=(\"/etc/nginx\" \"/opt\" \"/var/www\")\n\n# 定义数据库账户密码\ndb_user=\"user\"\ndb_password=\"passwd\"\n# 定义要备份的数据库名称列表\ndb_names=(\"mydb\")\nDATE=$(date +%Y%m%d)\n# 定义生成的备份文件名,以日期命名\nbackup_file=\"backup_${DATE}.tar.gz\"\n\n# 输出当前时间和开始信息\nstart_time=$(date +%s)\necho \"======================Backup started at $(date)=========================\"\n\n# 创建一个临时目录来存放SQL文件\ntemp_dir=\"temp_backup\"\nmkdir ${temp_dir}\n\n# 导出每个数据库到SQL文件\nfor db_name in \"${db_names[@]}\"; do\n    sql_file=\"${temp_dir}/${db_name}.sql\"\n    mysqldump -u ${db_user} -p${db_password} ${db_name} &gt;${sql_file}\ndone\n\n# 将目录和SQL文件添加到备份中\ntar -czf ${backup_file} --transform 's,^,backup/,' \"${directories[@]}\" -C ${temp_dir} .\n\n# 删除临时目录及其中的SQL文件\nrm -rf ${temp_dir}\n\n# 计算并输出耗时\nend_time=$(date +%s)\nelapsed_time=$((end_time - start_time))\n\n# 获取备份文件的大小\nbackup_file_size=$(stat --format \"%s\" ${backup_file})\n\n# 输出完成信息、备份文件大小和耗时\necho \"Backup completed. File: ${backup_file}, Size:$(numfmt --to=iec-i --suffix=B ${backup_file_size})\"\n\n# WebDav上传, 路径中的serverBackup要求是坚果云上已创建好的文件夹, 也可以不填最后这个路径, 则是上传到根目录\necho \"Uploading...\"\ncadaver https://dav.jianguoyun.com/dav/serverBackup &lt;&lt; EOF\nput ${backup_file}\nquit\nEOF\necho \"Upload Done! \"\n\necho \"Elapsed time: ${elapsed_time} seconds\"\necho \"===================== Backup Done at $(date)=================================\"\n</pre>\n<figure class=\"alignnone size-full wp-image-187\">通过<code>bash backup.sh</code> 测试一下, 如果没问题就可以进行下一步了 <a href=\"https://cdn.merack.top/wp-content/uploads/2025/06/88f8cca6-9d32-3edc-76f4-60b98984dc5c.png\"><img loading=\"lazy\"  src=\"https://cdn.merack.top/wp-content/uploads/2025/06/88f8cca6-9d32-3edc-76f4-60b98984dc5c.png\" alt=\"\" width=\"960\" height=\"327\" data-is-external-image=\"true\"></figure></a></p>\n<h2>设定crontab定时任务</h2>\n<p>让脚本每周一凌晨3点定时运行并输出日志到指定文件</p>\n<pre>0 3 * * 1 /root/backup.sh &gt;&gt; /opt/log/backup.log</pre>\n<figure class=\"alignnone size-full wp-image-188\">关于crontab更多写法请自行查找吧 <a href=\"https://cdn.merack.top/wp-content/uploads/2025/06/169908cf-306f-66d8-c99d-94c6725decef.png\"><img loading=\"lazy\"  src=\"https://cdn.merack.top/wp-content/uploads/2025/06/169908cf-306f-66d8-c99d-94c6725decef.png\" alt=\"\" width=\"1422\" height=\"504\" data-is-external-image=\"true\"></figure></a></p>\n<h2>扩展</h2>\n<p>如果你的备份文件比较大, 坚果云的免费流量无法满足你的要求, 可以考虑使用各云服务商的对象存储, 看了七牛, 阿里, 腾讯的都不是很贵, 也提供了shell上传的示例代码. 如果你的服务器在国外, 那么像Amazon, Cloudflare等国外云服务商的对象存储貌似更加便宜.</p>",
            "author": {
                "name": "Merack"
            },
            "tags": [
                   "Linux"
            ],
            "date_published": "2025-06-01T17:38:27+08:00",
            "date_modified": "2025-06-01T17:38:27+08:00"
        },
        {
            "id": "https://blog.merack.top/yong-flutterkai-fa-de-yi-kuan-ji-yu-sui-ji-jiang-li-ji-zhi-de-zhuan-zhu-xue-xi-app.html",
            "url": "https://blog.merack.top/yong-flutterkai-fa-de-yi-kuan-ji-yu-sui-ji-jiang-li-ji-zhi-de-zhuan-zhu-xue-xi-app.html",
            "title": "用Flutter开发的一款基于随机奖励机制的专注学习app",
            "summary": "灵感来源于之前看到的一个B站视频: BV1naLozQEBq , 觉得挺有意思的, 联想到很久之前学的Flutter也没有怎么练习过, 于是本着复习Flutter的想法断断续续捣鼓出的一个玩具. 原理引用下GitHub上JokerQianwei/Focus 项目的README: 还可以在这个链接了解: https://www.yuque.com/u43692620/yyl2g7/fup4ss9g56olg3gy&hellip;",
            "content_html": "<p>灵感来源于之前看到的一个B站视频: <a href=\"https://www.bilibili.com/video/BV1naLozQEBq\" rel=\"nofollow\">BV1naLozQEBq</a>  , 觉得挺有意思的, 联想到很久之前学的Flutter也没有怎么练习过, 于是本着复习Flutter的想法断断续续捣鼓出的一个玩具.</p>\n<h2>机制简单介绍</h2>\n<ol>\n<li>有一个专注时间和休息时间, 专注时间一到就开始进入休息时间, 休息时间结束完成一个周期</li>\n<li>定义一个区间, 每次生成一个在这个区间的随机秒数, 每经过这么多秒就在专注时间内插入一个微休息, 微休息时间很短大概是10s</li>\n<li>微休息单独计时, 不影响主专注时间的计时且只发生在专注阶段</li>\n</ol>\n<p>原理引用下GitHub上<a href=\"https://github.com/JokerQianwei/Focus/\">JokerQianwei/Focus</a>  项目的README:</p>\n<blockquote><strong>间隔效应 (Gap Effects)</strong>：神经科学家 Andrew Huberman 教授指出，学习过程中短暂的、几秒钟的停顿，可以触发大脑神经元的快速回顾机制，有效提升学习和记忆效率。Random Focus 的随机提示音和小憩功能正是基于此原理，引导用户利用碎片化的时间进行高效的信息巩固。（参考：Huberman Lab 播客 - <a href=\"https://www.bilibili.com/video/BV1BopsenEaW/?share_source=copy_web&amp;vd_source=80067a9d068c4c06488f9be7364e3539\" rel=\"nofollow\">像天才一样学习</a>，1:22:03 处）</blockquote>\n<blockquote><strong>随机奖励 (Random Rewards)</strong>：心理学研究表明，不可预测的随机奖励比固定奖励更能激发持续的行为动力。本应用中的随机提示音，在提醒休息的同时，也扮演了积极反馈的角色，帮助用户克服长时间专注带来的疲惫感，保持学习或工作的动力。（灵感来源：<a href=\"https://www.bilibili.com/video/BV1naLozQEBq/?share_source=copy_web&amp;vd_source=80067a9d068c4c06488f9be7364e3539\" rel=\"nofollow\">为什么我能每天学习10小时</a>）</blockquote>\n<p>还可以在这个链接了解: <a href=\"https://www.yuque.com/u43692620/yyl2g7/fup4ss9g56olg3gy\">https://www.yuque.com/u43692620/yyl2g7/fup4ss9g56olg3gy</a></p>\n<h2>成品展示</h2>\n<figure class=\"alignnone size-full wp-image-197\">下载地址(仅安卓): <a href=\"https://pan.quark.cn/s/db7160d17739\">https://pan.quark.cn/s/db7160d17739</a>  提取码：TnbS 更新: <a href=\"https://github.com/Merack/time_machine/releases\">https://github.com/Merack/time_machine/releases</a> <a href=\"https://cdn.merack.top/wp-content/uploads/2025/06/38e2bd2c-e475-69bb-bb42-2a92311a71b9.jpeg\"><img  src=\"https://cdn.merack.top/wp-content/uploads/2025/06/38e2bd2c-e475-69bb-bb42-2a92311a71b9.jpeg\" alt=\"\" width=\"729\" height=\"500\" data-is-external-image=\"true\"></figure></a> <a href=\"https://cdn.merack.top/wp-content/uploads/2025/06/0cefa0c1-7433-b6a7-66e2-49f26440243b.jpeg\"><figure class=\"alignnone size-full wp-image-198\"><img loading=\"lazy\"  src=\"https://cdn.merack.top/wp-content/uploads/2025/06/0cefa0c1-7433-b6a7-66e2-49f26440243b.jpeg\" alt=\"\" width=\"709\" height=\"500\" data-is-external-image=\"true\"></figure></a></p>\n<h2>代码设计</h2>\n<h3>总体思路</h3>\n<p>Dart 里的<code>Timer</code>类正好提供了来做倒计时的方法<code>periodic</code>, 函数签名: <code>factory Timer.periodic(Duration duration, void callback(Timer timer))</code>. 实际上它的作用是每隔一个<code>duration</code>周期执行一次回调方法<code>callback</code>, 那么我们就可以让这个周期为1s, 用变量存储需要倒计时的秒数, 在callback里一直让这个变量做-1操作, 直到为0就可以了.核心逻辑如下:</p>\n<pre class=\"EnlighterJSRAW\" data-enlighter-language=\"generic\">void _startFocusCountdown() {\n    _timer = Timer.periodic(const Duration(seconds: 1), (timer) {\n      if (remainingFocusTime &gt; 0) {\n        remainingFocusTime--;\n      } else {\n        _handleFocusTimerComplete();\n      }\n    });\n  }</pre>\n<p>由于专注和微休息是单独计时, 所以创建两个Timer来计时, 一个用作专注与休息, 一个用作微休息的到来的倒计时与微休息期间的倒计时.</p>\n<h3>状态维护</h3>\n<p>为了让应用知道现在处于什么阶段了, 我们还需要维护当前的状态信息. 目前是设计了5个状态: 专注状态, 大休息状态, 微休息状态, 暂停状态, 停止状态. 用了一个枚举类来保存, 同时<code>isRunning</code>变量用来标识当前专注计时器是否处于运行状态</p>\n<pre class=\"EnlighterJSRAW\" data-enlighter-language=\"generic\">enum TimerStatus {\n  focus,      // 专注状态\n  microBreak, // 微休息状态\n  bigBreak,   // 大休息状态\n  paused,     // 暂停状态\n  stopped     // 停止状态\n}\n\n// 是否正在运行\nvar isRunning = false</pre>\n<h3>状态切换</h3>\n<p>在当前状态计时结束后要进入下一个阶段, 执行相关操作, 因此定义了一系列操作方法. <strong>1.重置</strong></p>\n<pre class=\"EnlighterJSRAW\" data-enlighter-language=\"generic\">void resetTimer() {\n   // 停止两个计时器\n    _timer?.cancel();\n    _microBreakTimer?.cancel();\n    // 状态更新为停止\n    timerStatus = TimerStatus.stopped;\n    // 重置剩余时间和总时间\n    remainingFocusTime = state.focusTimeSeconds;\n    totalTime = state.focusTimeSeconds;\n    // 更新运行状态\n    isRunning = false;\n    // 生成下一个微休息时间\n    generateNextMicroBreakInterval();\n}</pre>\n<p><strong>2.开始</strong></p>\n<pre class=\"EnlighterJSRAW\" data-enlighter-language=\"generic\">/// 开始计时器\n  void _startTimer() {\n    if (timerStatus == TimerStatus.stopped) {\n      // 首次启动,直接进入专注会话\n      _startFocusSession();\n    } else {\n      // 从暂停状态恢复\n      if (timerStatus == TimerStatus.paused) {\n        // 更新 isRunning 状态\n        isRunning = true;\n        // 如果之前的状态是 focus 或者 microBreak, 则恢复为专注状态\n        if ((previousStatus == TimerStatus.focus) ||\n            (previousStatus == TimerStatus.microBreak)) {\n          timerStatus = TimerStatus.focus;\n        } else {\n          // 恢复为之前的状态, 逻辑上这里应该只能是 bigBreak\n          timerStatus = previousStatus;\n        }\n        // 重新开始专注计时器\n        _startFocusCountdown();\n        // 重新生成随机间隔\n        generateNextMicroBreakInterval();\n        // 重新开始微休息计时器\n        _startMicroBreakCountdown();\n      }\n    }\n  }</pre>\n<p>3. 暂停</p>\n<pre class=\"EnlighterJSRAW\" data-enlighter-language=\"generic\">/// 暂停计时器\n  void _pauseTimer() {\n    // 一同暂停专注和微休息\n    _timer?.cancel();\n    _microBreakTimer?.cancel();\n    // 保存之前的状态用于恢复\n    previousStatus = timerStatus;\n    // 状态更新\n    timerStatus = TimerStatus.paused;\n    isRunning = false;\n  }</pre>\n<h4>专注计时器相关</h4>\n<p><strong>1. 专注计时器计数逻辑, 专注计时和休息计时共用</strong></p>\n<pre class=\"EnlighterJSRAW\" data-enlighter-language=\"generic\">void _startFocusCountdown() {\n  _timer = Timer.periodic(const Duration(seconds: 1), (timer) {\n    if (remainingFocusTime &gt; 0) {\n      remainingFocusTime--;\n    } else {\n    // 处理专注计时器完成的函数\n      _handleFocusTimerComplete();\n    }\n  });\n}</pre>\n<p><strong>2. 处理专注计时器完成的函数, 专注计时和休息计时共用</strong></p>\n<pre class=\"EnlighterJSRAW\" data-enlighter-language=\"generic\">void _handleFocusTimerComplete() {\n   _timer?.cancel();\n\n   switch (timerStatus) {\n     case TimerStatus.focus:\n       _completeFocusSession();\n       break;\n     // 如果专注计时走完正好又处于微休息期间时, 仍然认为完成了专注任务\n     case TimerStatus.microBreak:\n       _completeFocusSession();\n       break;\n     case TimerStatus.bigBreak:\n       _completeBigBreak();\n       break;\n     default:\n       break;\n   }\n }</pre>\n<p><strong>3.开始专注会话</strong></p>\n<pre class=\"EnlighterJSRAW\" data-enlighter-language=\"generic\">/// 开始专注会话\n  void _startFocusSession() {\n    // 初始化状态\n    timerStatus = TimerStatus.focus;\n    remainingFocusTime = focusTimeSeconds;\n    totalTime = focusTimeSeconds;\n    isRunning = true;\n    generateNextMicroBreakInterval();\n   // 同时开启两个计时器\n    _startFocusCountdown();\n    _startMicroBreakCountdown();\n  }</pre>\n<p><strong>4. 处理专注状态完成</strong></p>\n<pre class=\"EnlighterJSRAW\" data-enlighter-language=\"generic\">/// 完成专注会话\n  void _completeFocusSession() {\n    // 不在专注时段, 微休息停止计时\n    _microBreakTimer?.cancel();\n\n    // 播放专注完成音效\n    _playAudio('audio/wakeup.mp3');\n\n    // 增加完成专注数\n    state.completedCycles.value++;\n\n    // 如果用户设置大休息时间为0, 则跳过休息阶段\n    if (state.bigBreakTimeSeconds.value == 0) {\n      resetTimer();\n      _startFocusSession();\n      return;\n    }\n\n    // 进入大休息状态\n    state.timerStatus.value = TimerStatus.bigBreak;\n    state.remainingFocusTime.value = state.bigBreakTimeSeconds.value;\n    state.totalTime.value = state.bigBreakTimeSeconds.value;\n\n    // 开始大休息倒计时\n    _startFocusCountdown();\n  }</pre>\n<p><strong>5.处理休息状态完成</strong> 但休息完成时就说明一个周期完成了, 于是进入下一个周期<code>_startFocusSession()</code> 或者重置一切让计时器停止<code>resetTimer()</code>, 后期再加个flag控制这个行为吧</p>\n<pre class=\"EnlighterJSRAW\" data-enlighter-language=\"generic\">/// 完成大休息\n  void _completeBigBreak() {\n    // 播放大休息结束音效\n    _playAudio('audio/alarm-wood.mp3');\n    // 完成了一个周期, 开始新的专注会话\n    // _startFocusSession();\n    // 重置计数器\n    resetTimer();\n  }</pre>\n<h4>微休息计时器相关</h4>\n<p>微休息会话的开启其实是由前面的开始专注会话<code>_startFocusSession()</code>里随专注计时器一同开启的, 因此微休息这里只要处理微休息计数器逻辑和微休息状态完成的逻辑就可以了. 但是微休息来临计时的完成和微休息的完成都没有像专注和大休息一样分开写相应的complete函数, 而是都把complete的逻辑分散到<code>_startMicroBreakCountdown</code> 和<code>_handleMicroBreakStatus</code>里了, 所以这部分看起来有点屎山, 后面有空再优化 1.处理微休息到来间隔计时和微休息期间计时</p>\n<pre class=\"EnlighterJSRAW\" data-enlighter-language=\"generic\">void _startMicroBreakCountdown() {\n    // 检查微休息是否启用\n    if (!microBreakEnabled) {\n      return;\n    }\n\n    // 如果微休息时间设置为0也不启用微休息\n    if (microBreakTimeSeconds == 0) {\n      return;\n    }\n    // 处理微休息到来时间倒计时\n    if (timerStatus == TimerStatus.focus) {\n      _microBreakTimer = Timer.periodic(const Duration(seconds: 1), (timer) {\n        if (nextMicroBreakTime &gt; 0) {\n          nextMicroBreakTime--;\n        } else {\n        // 处理微休息计数器计时完成逻辑\n          _handleMicroBreakStatus(isStartMicroBreak: true);\n        }\n      });\n    }\n    // 处理微休息期间倒计时\n    if (timerStatus == TimerStatus.microBreak) {\n      _microBreakTimer = Timer.periodic(const Duration(seconds: 1), (timer) {\n        if (remainingMicroBreakTime &gt; 0) {\n          remainingMicroBreakTime--;\n        } else {\n          _handleMicroBreakStatus(isStartMicroBreak: false);\n        }\n      });\n    }\n  }</pre>\n<p>2. 处理微休息计数器计时完成逻辑</p>\n<pre class=\"EnlighterJSRAW\" data-enlighter-language=\"generic\">void _handleMicroBreakStatus({required bool isStartMicroBreak}) {\n    // 开始微休息\n    if (isStartMicroBreak) {\n      _microBreakTimer?.cancel();\n\n      // 播放微休息开始音效\n      _playAudio('audio/drop.mp3');\n\n      // 进入微休息状态\n      timerStatus = TimerStatus.microBreak;\n\n      // 开始微休息倒计时\n      // 设置微休息时间\n      remainingMicroBreakTime = microBreakTimeSeconds;\n      _startMicroBreakCountdown();\n    } else {\n      // 微休息结束\n      _microBreakTimer?.cancel();\n\n      // 播放微休息结束音效\n      _playAudio('audio/ding.mp3');\n\n      // 更新状态\n      timerStatus = TimerStatus.focus;\n\n      generateNextMicroBreakInterval();\n      // 开始微休息倒计时\n      _startMicroBreakCountdown();\n    }\n  }</pre>\n<p>代码都是随想随写没什么技术含量, 包含界面部分的完整代码等后面再整理整理好就开源出来吧~ 更新: 已开源: <a href=\"https://github.com/Merack/time_machine\">https://github.com/Merack/time_machine</a></p>\n<h2>后续计划</h2>\n<ul>\n<li>数据统计</li>\n<li>自动开始控制</li>\n<li>自定义进度条颜色</li>\n<li>暗色模式</li>\n<li>禅模式</li>\n<li>开关提示音</li>\n<li>后台保活(尽量...)</li>\n<li>多语言--英文</li>\n</ul>\n<h2>后记</h2>\n<p>Flutter是跨平台的框架, 但是我只有安卓设备于是只做了安卓的. 而且也只是验证想法的练手作品也别指望它能有多好用, 我只是个菜鸡安卓杀后台的问题解决不了一点~ Flutter的声明式UI写界面确实比安卓原生开发用xml那套方便许多, 但页面元素一多起来层层嵌套也是很折磨人, 经常找括号和逗号要找半天. 体验下来觉得写UI还得是web三件套,怪不得Electron和Tauri这类的框架能这么流行. 那在移动端最接近web的应该是react native了吧, 听说JSI和新架构让rn性能有了不错的提升, 有机会再试试吧, 顺便捡一下学了但从没用过的react. 还有一点就是感觉Flutter有点太依赖生态了, 一些系统调用的功能如果没有相应的包那就得自己写FFI, rn应该也差不多, 不是原生的框架应该都这样吧~</p>",
            "author": {
                "name": "Merack"
            },
            "tags": [
            ],
            "date_published": "2025-05-18T19:14:00+08:00",
            "date_modified": "2025-06-08T19:23:58+08:00"
        },
        {
            "id": "https://blog.merack.top/rustxue-xi-bi-ji-rustzhong-de-box-rc-he-refcell.html",
            "url": "https://blog.merack.top/rustxue-xi-bi-ji-rustzhong-de-box-rc-he-refcell.html",
            "title": "Rust学习笔记: Rust中的Box, Rc 和 RefCell",
            "summary": "最近简单学了下rust, 发现它对内存的管理挺有意思的, 其中用的比较多是Box&lt;T&gt;, Rc&lt;T&gt; 和 RefCell&lt;T&gt;. 这里简单记录下自己的一些理解. Box::new() 用于在堆上分配数据，可以类比成Java和cpp中的new, 但不一样的是Java的GC会自动处理分配在堆上的数据,&hellip;",
            "content_html": "<p>最近简单学了下rust, 发现它对内存的管理挺有意思的, 其中用的比较多是Box&lt;T&gt;, Rc&lt;T&gt; 和 RefCell&lt;T&gt;. 这里简单记录下自己的一些理解.</p>\n<h2>1.Box&lt;T&gt;</h2>\n<p>Box::new() 用于在堆上分配数据，可以类比成Java和cpp中的new, 但不一样的是Java的GC会自动处理分配在堆上的数据, cpp需要手动free, 而rust里的Box 是在离开作用域时自动释放这个内存。</p>\n<pre class=\"EnlighterJSRAW\" data-enlighter-language=\"rust\">struct Data {\n    value: i32,\n}\n\nfn main() {\n    // 在栈上创建一个 Data 实例\n    let data_on_stack = Data { value: 10};\n    println!(\"栈上的数据: ({})\", data_on_stack.value);\n\n    // 使用 Box&lt;T&gt; 在堆上分配一个 Data 实例\n    let data_on_heap: Box&lt;Data&gt; = Box::new(Data { value: 20 });\n\n    // 我们可以像普通引用一样访问 Box 中的数据\n    println!(\"堆上的数据: ({})\", data_on_heap.value);\n\n    // 当 b 离开这个作用域时，堆上的 Data 对象会被自动释放\n    // 不需要手动调用 free 或 delete\n}</pre>\n<p>cargo run的结果:</p>\n<pre>栈上的数据: (10)\n堆上的数据: (20)</pre>\n<p>如果是新版cpp的话(C++11), 它更像是智能指针里的<code>std::unique_ptr</code></p>\n<pre class=\"EnlighterJSRAW\" data-enlighter-language=\"cpp\">#include &lt;iostream&gt;\n#include &lt;memory&gt; // 引入智能指针头文件\n\nclass Data {\npublic:\n    Data(int val) : value(val) {\n        std::cout &lt;&lt; \"Data(\" &lt;&lt; value &lt;&lt; \") constructed.\" &lt;&lt; std::endl;\n    }\n    ~Data() {\n        std::cout &lt;&lt; \"Data(\" &lt;&lt; value &lt;&lt; \") destructed.\" &lt;&lt; std::endl;\n    }\n    void printValue() const {\n        std::cout &lt;&lt; \"Value: \" &lt;&lt; value &lt;&lt; std::endl;\n    }\nprivate:\n    int value;\n};\n\nint main() {\n    // 创建 unique_ptr, 如果是C++14推荐使用 std::make_unique\n    // std::unique_ptr&lt;Data&gt; ptr1 = std::make_unique&lt;Data&gt;(10);\n\n    // C++11的创建方式:\n    std::unique_ptr&lt;Data&gt; ptr1(new Data(10));\n\n    if (ptr1) { // 检查指针是否有效\n        ptr1-&gt;printValue();\n    }\n\n    // unique_ptr里也有和rust类似的所有权机制\n    std::unique_ptr&lt;Data&gt; ptr2 = std::move(ptr1); // ptr1 现在为空\n\n    if (ptr2) {\n        std::cout &lt;&lt; \"ptr2 owns the object:\" &lt;&lt; std::endl;\n        ptr2-&gt;printValue();\n    }\n\n    // ptr1所指向的数据所有权已经移动到了ptr2, ptr1目前为空\n    if (!ptr1) {\n        std::cout &lt;&lt; \"ptr1 is null.\" &lt;&lt; std::endl;\n    }\n\n    // 当 ptr2 离开作用域时，它管理的对象会被自动销毁, 不用手动调用free\n    return 0;\n}</pre>\n<p>运行结果:</p>\n<pre>Data(10) constructed.\nValue: 10\nptr2 owns the object:\nValue: 10\nptr1 is null.\nData(10) destructed.</pre>\n<h2>2.Rc&lt;T&gt;</h2>\n<p>Rc&lt;T&gt; (Reference Counting) 可以理解为一个基于引用计数的指针, 使用<code>Rc::clone(&amp;data)</code>会增加1个data的引用计数, 当一个指向data的Rc指针销毁时data的引用计数会减1, 当引用计数为0时对象data会自动销毁.</p>\n<pre class=\"EnlighterJSRAW\" data-enlighter-language=\"generic\">use std::rc::Rc; // 引入 Rc\n\n#[derive(Debug)]\nstruct SharedData {\n    value: i32,\n}\n\nfn main() {\n    // 创建一个 SharedData 实例，并用 Rc 包装它\n    // data1 是第一个指向堆上 SharedData 的 Rc 指针\n    let data1 = Rc::new(SharedData { value: 10 });\n\n    // 打印初始引用计数(强引用)\n    println!(\"初始引用计数: {}\", Rc::strong_count(&amp;data1)); // 输出: 1\n\n    // 克隆 Rc 指针，这会增加引用计数\n    // data2 也指向堆上同一个 SharedData 实例\n    let data2 = Rc::clone(&amp;data1);\n    println!(\"克隆后 data1 的引用计数: {}\", Rc::strong_count(&amp;data1)); // 输出: 2\n    println!(\"data2 的引用计数: {}\", Rc::strong_count(&amp;data2));       // 输出: 2\n\n    { // 创建一个新的作用域\n        // data3 也指向同一个数据\n        let data3 = Rc::clone(&amp;data1);\n        println!(\"在新的作用域中，引用计数: {}\", Rc::strong_count(&amp;data1)); // 输出: 3\n    } // data3 在这里离开作用域，引用计数减 1\n\n    println!(\"data3 离开作用域后，引用计数: {}\", Rc::strong_count(&amp;data1)); // 输出: 2\n\n    // 我们可以通过任一 Rc 指针访问数据\n    println!(\"data1 中的数据: {:?}\", data1.value);\n    println!(\"data2 中的数据: {:?}\", data2.value);\n\n    // 当 data1 和 data2 都离开作用域时，引用计数变为 0，SharedData 会被释放\n}</pre>\n<p>cargo run结果:</p>\n<pre>初始引用计数: 1\n克隆后 data1 的引用计数: 2\ndata2 的引用计数: 2\n在新的作用域中，引用计数: 3\ndata3 离开作用域后，引用计数: 2\ndata1 中的数据: 10\ndata2 中的数据: 10</pre>\n<p>Rc 类似于c++11中的智能指针<code>std::shared_ptr</code></p>\n<pre class=\"EnlighterJSRAW\" data-enlighter-language=\"cpp\">#include &lt;iostream&gt;\n#include &lt;memory&gt; // 引入智能指针头文件\n#include &lt;vector&gt;\n\nclass SharedData {\npublic:\n    SharedData(int id) : value(id) {\n        std::cout &lt;&lt; \"SharedData(\" &lt;&lt; value &lt;&lt; \") acquired.\" &lt;&lt; std::endl;\n    }\n    ~SharedData() {\n        std::cout &lt;&lt; \"SharedData(\" &lt;&lt; value &lt;&lt; \") released.\" &lt;&lt; std::endl;\n    }\n    int get_value() const { return value; }\nprivate:\n    int value;\n};\n\nint main() {\n    // 创建 shared_ptr\n    std::shared_ptr&lt;SharedData&gt; sp1 = std::make_shared&lt;SharedData&gt;(10);\n    std::cout &lt;&lt; \"sp1 use_count: \" &lt;&lt; sp1.use_count() &lt;&lt; std::endl; // 输出: 1\n\n    // sp2与sp1共享所有权\n    std::shared_ptr&lt;SharedData&gt; sp2 = sp1; // 拷贝构造，引用计数增加\n    std::cout &lt;&lt; \"sp1 use_count: \" &lt;&lt; sp1.use_count() &lt;&lt; std::endl; // 输出: 2\n    std::cout &lt;&lt; \"sp2 use_count: \" &lt;&lt; sp2.use_count() &lt;&lt; std::endl; // 输出: 2\n\n    // 重置 sp1\n    sp1.reset(); // sp1 不再指向任何对象，引用计数减1\n    std::cout &lt;&lt; \"After sp1.reset(), sp2 use_count: \" &lt;&lt; sp2.use_count() &lt;&lt; std::endl; // 输出: 1\n\n    // 当所有指向 SharedData的 shared_ptr 离开作用域或被重置时，对应的 SharedData 对象会被销毁。\n    return 0;\n}</pre>\n<p>使用Rc时要额外注意循环引用的问题, 即不同对象间相互引用形成闭环, 这样计数器永远不为0, 所指向的内存就无法释放.解决方法是用<code>Weak&lt;T&gt;</code>, 对应C++11 中的 <code>std::weak_ptr</code> Rc::clone 做到了让多个所有者共享同一份数据的所有权, 但它所指向的数据是只读的, 不可以修改. 但是可以配合下面提到的RefCell来实现数据的\"内部可变性\"</p>\n<h2>3.RefCell&lt;T&gt;</h2>\n<h3>内部可变性</h3>\n<p>RefCell&lt;T&gt;中的T被设计成总是可以修改的, 即使外部指向RefCell&lt;T&gt;的是一个不可变的引用. 因此它可以用来实现内部数据的可变性. 它常常与上文提到的Rc&lt;T&gt;配合使用, 来实现共享所有权的情况下又能修改里面的数据(Rc&lt;T&gt;里的数据默认是只读的).</p>\n<pre class=\"EnlighterJSRAW\" data-enlighter-language=\"generic\">use std::cell::RefCell; // 引入 RefCell\nuse std::rc::Rc;       // 与 Rc 配合使用\n\n#[derive(Debug)]\nstruct MutableSharedData {\n    value: i32,\n}\n\nfn main() {\n    // 创建一个 Rc&lt;RefCell&lt;MutableSharedData&gt;&gt;\n    // Rc 允许多所有权\n    // RefCell 允许内部可变性\n    let shared_data_rc = Rc::new(RefCell::new(MutableSharedData { value: 10 }));\n\n    // 克隆 Rc，创建另一个所有者\n    let owner1 = Rc::clone(&amp;shared_data_rc);\n    let owner2 = Rc::clone(&amp;shared_data_rc);\n\n    // owner1 通过 RefCell 的 borrow_mut() 获取可变借用，并修改数据\n    {\n        let mut mutable_borrow = owner1.borrow_mut(); // 获取可变借用\n        mutable_borrow.value += 5;\n        println!(\"owner1 修改后: {:?}\", mutable_borrow); // 输出15\n    } // 可变借用在这里释放\n\n    // owner2 通过 RefCell 的 borrow() 获取不可变借用，并读取数据\n    {\n        let immutable_borrow = owner2.borrow(); // 获取不可变借用\n        println!(\"owner2 读取到: {:?}\", immutable_borrow);  // 输出 15\n    } // 不可变借用在这里释放\n\n    // 再次通过 shared_data_rc 修改\n    shared_data_rc.borrow_mut().value = 100;\n    println!(\"直接通过 shared_data_rc 修改后: {:?}\", shared_data_rc.borrow()); // 输出 100\n}</pre>\n<p>cargo run 结果:</p>\n<pre>owner1 修改后: MutableSharedData { value: 15 }\nowner2 读取到: MutableSharedData { value: 15 }\n直接通过 shared_data_rc 修改后: MutableSharedData { value: 100 }</pre>\n<h3>运行时借用规则检查</h3>\n<p>从上面的示例代码可以看出, 对RefCell&lt;T&gt; 里的数据的操作仍然遵循rust的借用规则, 即: 只能存在单一可变引用或任意数量的不可变引用. 其借用主要是通过<code>borrow_mut()</code> 和 <code>borrow()</code> 这两个函数实现,  但有意思的是RefCell&lt;T&gt;的借用检查是发生在运行阶段而不是像普通的借用检查一样发生在编译时, 也就是说编译器会忽略这个\"Cell\"里的数据的借用检查, 即使你违反规定了也能编译通过, 但是会在运行时报错. 下面是一段违反了借用规则的错误代码:</p>\n<pre class=\"EnlighterJSRAW\" data-enlighter-language=\"rust\">use std::cell::RefCell;\n\nfn main() {\n    let data = RefCell::new(String::from(\"hello\")); \n\n    let _r1 = data.borrow();       // 获取一个不可变借用，计数器记录有一个不可变借用\n    let _r2 = data.borrow_mut(); // 这里违反了借用规则,但是能编译通过, 但会在运行时错误！\n\n    // 若要成功获取 r2，必须先让 r1 失效（离开作用域或显式 drop）\n    // drop(r1); // 显式 drop r1\n    // let r2_ok = data.borrow_mut();\n    // println!(\"r2_ok can now be used\");\n}</pre>\n<figure class=\"alignnone size-full wp-image-190\">这里的_r2 是明显违反了借用规则的, 但是cargo test 和cargo build 都能通过, 因为他们都发生在编译时 <a href=\"https://cdn.merack.top/wp-content/uploads/2025/06/e0b67c34-0baf-bc0b-61b9-7c8b37b01010.png\"><img  src=\"https://cdn.merack.top/wp-content/uploads/2025/06/e0b67c34-0baf-bc0b-61b9-7c8b37b01010.png\" alt=\"\" width=\"870\" height=\"288\" data-is-external-image=\"true\"></figure></a> 但是 cargo run时就会发生错误, 因为在运行时每次调用<code>borrow_mut()</code> 和 <code>borrow()</code>都会出发借用检查 <a href=\"https://cdn.merack.top/wp-content/uploads/2025/06/aff5a006-8e46-d47a-da13-c717eee21b46.png\"><figure class=\"alignnone size-full wp-image-191\"><img loading=\"lazy\"  src=\"https://cdn.merack.top/wp-content/uploads/2025/06/aff5a006-8e46-d47a-da13-c717eee21b46.png\" alt=\"\" width=\"757\" height=\"181\" data-is-external-image=\"true\"></figure></a> 所以在使用RefCell&lt;T&gt; 时要特别小心里面数据的借用情况, 编译器不会帮你做检查只能依赖程序员自己分析.</p>\n<h2>后记</h2>\n<p>rust学起来难度确实比其他语言陡峭, 但所有权与借用规则其实不是很难理解, 个人感觉真正不好学的还是rust里生命周期, 经常搞不明白什么时候该加什么时候不用加. 就算加上了也只是让代码能编译通过而已, 自己也还不会推断这个生命周期到底能持续多长, 后面还得慢慢学.</p>",
            "author": {
                "name": "Merack"
            },
            "tags": [
            ],
            "date_published": "2025-04-10T20:07:00+08:00",
            "date_modified": "2025-06-04T19:07:39+08:00"
        },
        {
            "id": "https://blog.merack.top/shi-yong-cloudflare-workerjia-su-cloudflare-r2fang-wen-su-du.html",
            "url": "https://blog.merack.top/shi-yong-cloudflare-workerjia-su-cloudflare-r2fang-wen-su-du.html",
            "title": "使用Cloudflare worker加速Cloudflare R2访问速度",
            "summary": "cloudflare R2 提供了免费10G的对象存储并且兼容Amazon S3 api 操作, 与大多数对象存储提供商不一样的是R2的流出流量是免费的, 不用担心请求被恶意刷爆第二天银行来收房子的情况发生. 但是cloudflare给R2分配的ip都是xxx.xxx.xxx.1形式的ip, 这种ip节点在国内的访问体验很不好,&hellip;",
            "content_html": "<figure class=\"alignnone size-full wp-image-169\">cloudflare R2 提供了免费10G的对象存储并且兼容Amazon S3 api 操作, 与大多数对象存储提供商不一样的是R2的流出流量是免费的, 不用担心请求被恶意刷爆第二天银行来收房子的情况发生. 但是cloudflare给R2分配的ip都是<strong>xxx.xxx.xxx.1</strong>形式的ip, 这种ip节点在国内的访问体验很不好, 特别是在移动网络下, 基本无法访问. <a href=\"https://cdn.merack.top/wp-content/uploads/2025/03/7a2f2732-8432-8240-5b2c-8e317f67adf3.png\"><img loading=\"lazy\"  src=\"https://cdn.merack.top/wp-content/uploads/2025/03/7a2f2732-8432-8240-5b2c-8e317f67adf3.png\" alt=\"\" width=\"766\" height=\"823\" data-is-external-image=\"true\"></figure></a> 然而计算机领域里有句叫'没有什么问题是加一个中间层不能解决的', 而cloudflare里的worker刚好可以当这个'中间层'. worker是cloudflare提供的一个可以运行js/ts代码的serverless容器.</p>\n<h2>设计原理</h2>\n<figure class=\"alignnone size-full wp-image-179\">我们无法更改cloudflare为R2分配的ip, 但是worker的路由我们是可以配置. 由此我们可以通过优选好的路由连接到worker, 然后让worker作为中间人去帮我们访问R2的资源, worker和r2同属于cloudflare网络, 它们之间的通信会非常快. 这样一来就能实现R2的'加速'访问. <a href=\"https://cdn.merack.top/wp-content/uploads/2025/03/78935e73-35ca-e855-23db-17a42b2a8c0d.png\"><img loading=\"lazy\"  src=\"https://cdn.merack.top/wp-content/uploads/2025/03/78935e73-35ca-e855-23db-17a42b2a8c0d.png\" alt=\"\" width=\"636\" height=\"276\" data-is-external-image=\"true\"></figure></a> 本篇文章演示中R2绑定的访问域名是<strong>static.merack.top</strong>, worker通过worker路由绑定的域名是<strong>cdn.merack.top</strong>. 其中cdn.merack.top是最终给用户看到的域名. 用户向cdn.merack.top发出请求调用worker, worker请求R2: static.merack.top, 将R2的数据返回给用户.</p>\n<h2>创建worker</h2>\n<figure class=\"alignnone size-full wp-image-170\">点击左侧workers和pages, 新建一个hello world 的worker, 不用选其他模板. <a href=\"https://cdn.merack.top/wp-content/uploads/2025/03/e6015d68-3116-04a4-94a0-b208e0e802dd.png\"><img loading=\"lazy\"  src=\"https://cdn.merack.top/wp-content/uploads/2025/03/e6015d68-3116-04a4-94a0-b208e0e802dd.png\" alt=\"\" width=\"798\" height=\"423\" data-is-external-image=\"true\"></figure></a> 然后点击右上角的编辑代码按钮修改为如下代码</p>\n<pre class=\"EnlighterJSRAW\" data-enlighter-language=\"js\">const R2_DOMAIN = 'static.merack.top'; // 改成自己的R2公共访问域名\n\nasync function handleRequest(request) {\n  try {\n    const url = new URL(request.url);\n    \n    // 构建新的R2资源URL\n    const targetUrl = new URL(`https://${R2_DOMAIN}`);\n    targetUrl.pathname = url.pathname;\n    targetUrl.search = url.search;\n\n    // 复制并修改请求头\n    const headers = new Headers(request.headers);\n    headers.set('Host', R2_DOMAIN);\n    headers.delete('Cookie'); // 移除不必要的cookie头\n\n    // 创建新请求\n    const newRequest = new Request(targetUrl, {\n      method: request.method,\n      headers: headers,\n      redirect: 'follow'\n    });\n\n    let response = await fetch(newRequest);\n    return response;\n  } catch (err) {\n    // 错误处理\n    return new Response(err.stack, { \n      status: 500,\n      headers: { 'Content-Type': 'text/plain' }\n    });\n  }\n}\n\n// 监听所有请求\naddEventListener('fetch', event =&gt; {\n  event.respondWith(handleRequest(event.request));\n});</pre>\n<p><code>R2_DOMAIN</code> 常量改成自己的R2公共访问域名, 比如我这里是static.merack.top, 然后点击部署</p>\n<h2>配置worker路由</h2>\n<figure class=\"alignnone size-full wp-image-177\">点击设置-&gt;域和路由, 点击右上方的添加按钮, 类型选择<strong>路由</strong> <a href=\"https://cdn.merack.top/wp-content/uploads/2025/03/49676e52-e8e6-e7b1-f1ee-5dfadc0517a0.png\"><img loading=\"lazy\"  src=\"https://cdn.merack.top/wp-content/uploads/2025/03/49676e52-e8e6-e7b1-f1ee-5dfadc0517a0.png\" alt=\"\" width=\"490\" height=\"466\" data-is-external-image=\"true\"></figure></a></p>\n<figure class=\"alignnone size-full wp-image-178\">接下来填入需要面向用户的那个域名, 路径填/*, 例如我这里填的就是<strong>cdn.merack.top/* </strong> <a href=\"https://cdn.merack.top/wp-content/uploads/2025/03/5ec85094-a28c-82db-e8e1-fa001a47ecd2-1.png\"><img  src=\"https://cdn.merack.top/wp-content/uploads/2025/03/5ec85094-a28c-82db-e8e1-fa001a47ecd2-1.png\" alt=\"\" width=\"1249\" height=\"480\" data-is-external-image=\"true\"></figure></a> 这样用户访问cdn.merack.top时就触发worker去代理请求到R2, 但是此时还并不是优选的路由, 我们还需要修改下DNS解析 添加DNS记录让cdn.merack.top指向优选好的cloudflare cdn节点ip, 关于cf如何优选ip网上有很多教程就不赘述了, 图方便的话可以直接添加一个<strong>cname</strong>记录到别人的优选域名, 这里我用的是 <strong>cloudflare.182682.xyz</strong> , 也可以填我的博客域名<strong>www.merack.top</strong> , 但是注意后面的小黄云记得关闭, 让其状态为 '仅DNS' 模式, 这样你的cname才有意义. <a href=\"https://cdn.merack.top/wp-content/uploads/2025/03/2a8003ad-6428-d0c1-fda8-b9ccf732b974.png\"><figure class=\"alignnone size-full wp-image-180\"><img loading=\"lazy\"  src=\"https://cdn.merack.top/wp-content/uploads/2025/03/2a8003ad-6428-d0c1-fda8-b9ccf732b974.png\" alt=\"\" width=\"1345\" height=\"154\" data-is-external-image=\"true\"></figure></a> 点击保存后就可以将我们的访问域名换成worker路由的域名看看效果了.</p>\n<h2>测试</h2>\n<figure class=\"alignnone size-full wp-image-172\">经过一番折腾后效果对比以前有了很大提升, 但还是有些地区无法正常访问, 这取决于当地的网络状况和优选ip的质量. 如果要做到100%的可用性的话, 建议还是花点钱买个好点的服务, 比如Amazon S3 + Amazon Cloudfont, 如果你的域名有备案, 国内云服务商提供的对象存储也是不错的选择. <a href=\"https://cdn.merack.top/wp-content/uploads/2025/03/8875d1e9-91f1-ff21-1ff6-c344b2b64688.png\"><img loading=\"lazy\"  src=\"https://cdn.merack.top/wp-content/uploads/2025/03/8875d1e9-91f1-ff21-1ff6-c344b2b64688.png\" alt=\"\" width=\"748\" height=\"812\" data-is-external-image=\"true\"></figure></a></p>\n<h2>限制</h2>\n<figure class=\"alignnone size-full wp-image-174\">这个方案的限制主要来自worker. worker的免费订阅最关键的两个限制是CPU时间和日请求额度. <a href=\"https://cdn.merack.top/wp-content/uploads/2025/03/4394b2a9-0352-0851-da1d-1b706ac235d8.png\"><img loading=\"lazy\"  src=\"https://cdn.merack.top/wp-content/uploads/2025/03/4394b2a9-0352-0851-da1d-1b706ac235d8.png\" alt=\"\" width=\"452\" height=\"436\" data-is-external-image=\"true\"></figure></a></p>\n<ol>\n<li>每个请求的CPU时间是10毫秒, 超过这个时间请求会中断, 因此该方案不适用于大文件下载, 下到一半会中断. 10ms的时间最多能下到多大的文件没有测试过, 我用来请求存储本博客图片资源的R2的中值CPU时间不到1ms, 如果只是用作图片类型的文件加速, 10ms绰绰有余.</li>\n<li>worker的每日请求是十万, 因此该方案只能适用于日访问量在万级以下的小博客. 如果你的日访问量都到万级以上了, 应该不缺那点小钱去买个好点存储和cdn了吧. 为了防止脚本恶意刷请求, 可以配合cloudflare waf里的速率限制规格做一定的限制, 关于cloudflare waf我之前有写过文章介绍. <a href=\"https://cdn.merack.top/wp-content/uploads/2025/03/83ccfc6c-c70d-a18e-b134-d350e18df4e5.png\"><figure class=\"alignnone size-full wp-image-181\"><img loading=\"lazy\"  src=\"https://cdn.merack.top/wp-content/uploads/2025/03/83ccfc6c-c70d-a18e-b134-d350e18df4e5.png\" alt=\"\" width=\"808\" height=\"548\" data-is-external-image=\"true\"></figure></a></li>\n</ol>\n<h2>扩展</h2>\n<figure class=\"alignnone size-full wp-image-173\">1.本文例子中的使用场景是主要图片访问加速, 那么就会涉及到缓存时间的问题. worker返回的静态资源响应是会带有缓存控制的响应头(Cache-Control)的 <a href=\"https://cdn.merack.top/wp-content/uploads/2025/03/1821f6d1-320f-e877-4190-88014c4bfae4.png\"><img loading=\"lazy\"  src=\"https://cdn.merack.top/wp-content/uploads/2025/03/1821f6d1-320f-e877-4190-88014c4bfae4.png\" alt=\"\" width=\"1288\" height=\"389\" data-is-external-image=\"true\"></figure></a> 如果你想修改缓存的过期时间, 可以使用worker的cache api来控制, 具体可以参照官方文档: <a href=\"https://developers.cloudflare.com/workers/runtime-apis/cache/\">https://developers.cloudflare.com/workers/runtime-apis/cache/</a> <a href=\"https://developers.cloudflare.com/workers/reference/how-the-cache-works/\">https://developers.cloudflare.com/workers/reference/how-the-cache-works/</a> 2.虽说本文是以加速r2的访问为主题, 当也可用于加速其他的网站, 只要把代码中的 R2_DOMAIN 常量改改就可以做到. 但如果你代理的是某些版权意识比较看重的大公司的站点, 访问量大了他们可能会向cloudflare投诉, 认为你在进行'假冒官网', '欺骗用户'等欺诈行为, 那么cloudflare可能会封禁你的账号.</p>",
            "author": {
                "name": "Merack"
            },
            "tags": [
            ],
            "date_published": "2025-03-17T01:50:36+08:00",
            "date_modified": "2025-03-17T01:50:36+08:00"
        },
        {
            "id": "https://blog.merack.top/wu-xu-gong-wang-ip-tong-guo-cloudflare-tunnelsshi-xian-sshan-quan-nei-wang-chuan-tou.html",
            "url": "https://blog.merack.top/wu-xu-gong-wang-ip-tong-guo-cloudflare-tunnelsshi-xian-sshan-quan-nei-wang-chuan-tou.html",
            "title": "无需公网IP: 通过Cloudflare Tunnels实现SSH安全内网穿透",
            "summary": "大善人Cloudflare在zero trust的网络里提供了一个叫做Tunnels的东西, 通过它可以很轻松地建立多条连接到cloudflare 网络的隧道. Tunnels提供了多种常见协议支持, 比如HTTP, HTTPS, TCP, SSH, RDP,&hellip;",
            "content_html": "<p>大善人Cloudflare在zero trust的网络里提供了一个叫做Tunnels的东西, 通过它可以很轻松地建立多条连接到cloudflare 网络的隧道. Tunnels提供了多种常见协议支持, 比如HTTP, HTTPS, TCP, SSH, RDP, SMB等, 甚至还支持与本地Unix socket文件通信. 本文主要以SSH为例介绍Tunnels的用法(其他协议也大同小异), 可以用于以下场景:</p>\n<ul>\n<li>在没有公网ip的情况下实现内网穿透SSH连接内网机器</li>\n<li>在没有ipv6的环境下连接只有ipv6 ip的主机</li>\n<li>远程主机到本地的线路质量很差, 丢包严重造成SSH操作卡顿, 通过tunnels传输SSH来缓解</li>\n</ul>\n<figure class=\"alignnone size-full wp-image-142\">我这里以第一种场景为例, 内网中的主机是ubuntu 24.04.2 在后文我会把它称作服务端, 远程连接改服务端的pc是win 10, 后文我会称作客户端. 简单的原理图如下: <a href=\"https://cdn.merack.top/wp-content/uploads/2025/02/5566048f-e95e-5867-88a8-a3e59fcc811b.png\"><img loading=\"lazy\"  src=\"https://cdn.merack.top/wp-content/uploads/2025/02/5566048f-e95e-5867-88a8-a3e59fcc811b.png\" alt=\"\" width=\"822\" height=\"404\" data-is-external-image=\"true\"></figure></a></p>\n<h2>准备工作</h2>\n<ul>\n<li>一个NS解析在cloudflare的域名</li>\n<li>开通zero trust. zero trust的基础功能的免费的, 包括Tunnels, 但是需要绑定一个支付方式开通, 支持visa信用卡或者PayPal, 这里推荐PayPal, 因为PayPal可以绑定国内的银联卡, 无需信用卡.</li>\n</ul>\n<h2>创建Cloudflare Tunnels</h2>\n<figure class=\"alignnone wp-image-143\">登录Cloudflare控制台,然后进入页面左侧的Zero Trust → 网络→ Tunnels → 创建隧道。 隧道类型选择<strong>cloudflared</strong>, 自定义隧道名称（这里我以localSSH为例）。 <a href=\"https://cdn.merack.top/wp-content/uploads/2025/02/4a47a0db-6e60-853d-edfc-fdf08a5ca249.png\"><img loading=\"lazy\"  src=\"https://cdn.merack.top/wp-content/uploads/2025/02/4a47a0db-6e60-853d-edfc-fdf08a5ca249.png\" alt=\"\" width=\"787\" height=\"397\" data-is-external-image=\"true\"></figure></a></p>\n<h2><a href=\"https://cdn.merack.top/wp-content/uploads/2025/02/2c280a13-e230-0dea-97f9-5fc4e98f81b4.png\"><figure class=\"alignnone size-full wp-image-144\"><img loading=\"lazy\"  src=\"https://cdn.merack.top/wp-content/uploads/2025/02/2c280a13-e230-0dea-97f9-5fc4e98f81b4.png\" alt=\"\" width=\"1820\" height=\"645\" data-is-external-image=\"true\"></figure></a></h2>\n<h2>安装Cloudflared</h2>\n<figure class=\"alignnone size-full wp-image-145\">接下来会进入到cloudflared的安装指导页面, cloudflared是隧道的创建和连接客户端, 选择适合服务端的架构, 这里我是ubuntu, 所以选的是Debian, 64bit. 复制知道页面的命令在服务端运行, 这些命令运行后会创建一个开机自启Systemd服务以确保隧道的时刻可用性. <a href=\"https://cdn.merack.top/wp-content/uploads/2025/02/0e4159f4-3c21-5fb0-5769-c98db8008f07.png\"><img  src=\"https://cdn.merack.top/wp-content/uploads/2025/02/0e4159f4-3c21-5fb0-5769-c98db8008f07.png\" alt=\"\" width=\"1301\" height=\"788\" data-is-external-image=\"true\"></figure></a> <a href=\"https://cdn.merack.top/wp-content/uploads/2025/02/db16ac4c-ce4d-7374-ffdb-91102fa0419f.png\"><figure class=\"alignnone size-full wp-image-147\"><img loading=\"lazy\"  src=\"https://cdn.merack.top/wp-content/uploads/2025/02/db16ac4c-ce4d-7374-ffdb-91102fa0419f.png\" alt=\"\" width=\"868\" height=\"234\" data-is-external-image=\"true\"></figure></a> 同时客户端也需要下载cloudflared, 因为前面说过cloudflared同时也是连接器. 可以在同一个页面选择客户端的架构版本下载, 但是不要运行后面的<code>cloudflared service install</code> , 这个命令只有服务端需要运行.也可以在cloudflared的官方仓库下载各个版本的文件: <a href=\"https://github.com/cloudflare/cloudflared/releases/\">https://github.com/cloudflare/cloudflared/releases/</a></p>\n<h2>路由隧道</h2>\n<figure class=\"alignnone size-full wp-image-149\">点击完成后在这个页面填写协议, ip, 端口, 并为该隧道分配一个子域名用于连接, ip填127.0.0.1, 建议不要填localhost, 可能会不成功. 如果服务器是只有ipv6的情况下填127.0.0.1可能无法连接, 需要填[::1]. 点击完成后cloudflare会自动创建dns记录, 下面就可以测试连接了. <a href=\"https://cdn.merack.top/wp-content/uploads/2025/02/7f9dcfd8-1d53-75c0-893a-dea0d5b51525.png\"><img loading=\"lazy\"  src=\"https://cdn.merack.top/wp-content/uploads/2025/02/7f9dcfd8-1d53-75c0-893a-dea0d5b51525.png\" alt=\"\" width=\"1445\" height=\"585\" data-is-external-image=\"true\"></figure></a></p>\n<h2><a href=\"https://cdn.merack.top/wp-content/uploads/2025/02/1ddc25b1-517e-f30b-6182-3b6287aaa0b8.png\"><figure class=\"alignnone size-full wp-image-150\"><img loading=\"lazy\"  src=\"https://cdn.merack.top/wp-content/uploads/2025/02/1ddc25b1-517e-f30b-6182-3b6287aaa0b8.png\" alt=\"\" width=\"1346\" height=\"45\" data-is-external-image=\"true\"></figure></a></h2>\n<h2>连接测试</h2>\n<p>接下来通过ssh 的ProxyCommand 来让cloudflared把我们的ssh流量转发到隧道中:</p>\n<pre class=\"EnlighterJSRAW\" data-enlighter-language=\"ini\">ssh -o ProxyCommand=\"E:\\code\\go\\bin\\cloudflared access ssh --hostname localssh.merack.top\" root@localssh.merack.top</pre>\n<figure class=\"alignnone size-full wp-image-148\"><a href=\"https://cdn.merack.top/wp-content/uploads/2025/02/1bd04439-445c-9796-d421-ec63d74df98c.png\"><img loading=\"lazy\"  src=\"https://cdn.merack.top/wp-content/uploads/2025/02/1bd04439-445c-9796-d421-ec63d74df98c.png\" alt=\"\" width=\"1257\" height=\"172\" data-is-external-image=\"true\"></figure></a> cloudflared 的路径, 用户名, host都换成自己的. 如果嫌每次都要写这么长的命令麻烦, 那么可以将其配置到ssh的配置文件里, 在windows下是 <code>C:\\Users\\&lt;User&gt;\\.ssh\\config</code>文件(&lt;User&gt;替换为自己windows上的用户名)</p>\n<pre class=\"EnlighterJSRAW\" data-enlighter-language=\"ini\">Host localssh\n    User root\n    HostName localssh.merack.top\n    ProxyCommand E:\\code\\go\\bin\\cloudflared access ssh --hostname %h</pre>\n<figure class=\"alignnone size-full wp-image-151\"><a href=\"https://cdn.merack.top/wp-content/uploads/2025/02/cda78973-308e-404f-bbbf-1f6340df4690.png\"><img  src=\"https://cdn.merack.top/wp-content/uploads/2025/02/cda78973-308e-404f-bbbf-1f6340df4690.png\" alt=\"\" width=\"1063\" height=\"228\" data-is-external-image=\"true\"></figure></a> 这时我们只需要在命令行里输入 <code>ssh localssh</code> 即可 <a href=\"https://cdn.merack.top/wp-content/uploads/2025/02/14e8bf73-c584-f2f2-08ee-5ebd0ea94099.png\"><figure class=\"alignnone size-full wp-image-152\"><img loading=\"lazy\"  src=\"https://cdn.merack.top/wp-content/uploads/2025/02/14e8bf73-c584-f2f2-08ee-5ebd0ea94099.png\" alt=\"\" width=\"678\" height=\"175\" data-is-external-image=\"true\"></figure></a> 如果是通过公钥文件的方式连接, 只需再加一行 <code>IdentityFile</code> 配置就好:</p>\n<pre class=\"EnlighterJSRAW\" data-enlighter-language=\"ini\">Host localssh\n    User root\n    HostName localssh.merack.top\n    ProxyCommand E:\\code\\go\\bin\\cloudflared access ssh --hostname %h\n    IdentityFile C:\\path\\to\\.ssh\\id_remote-ssh</pre>\n<h2>扩展</h2>\n<p>通过上面的操作已经可以完成通过对内网服务器的ssh连接.此外tunnels还可以与zero trust中的其他功能想配合. 比如通过zero trust中的Access我们可以创建一个在浏览器上进行ssh操作tunnel所连接的内网服务器的网页, 无需写任何代码即可完成.下面进行简单的演示.</p>\n<h3>搭建网页版ssh控制台并配置访问策略</h3>\n<figure class=\"alignnone size-full wp-image-153\">为了方便演示, 我又在上文的localssh tunnels里配置了一个用于web ssh的公共访问域名: localpanel.merack.top <a href=\"https://cdn.merack.top/wp-content/uploads/2025/02/136a3288-c45f-b14e-ee91-0e926c4ee165.png\"><img  src=\"https://cdn.merack.top/wp-content/uploads/2025/02/136a3288-c45f-b14e-ee91-0e926c4ee165.png\" alt=\"\" width=\"1454\" height=\"430\" data-is-external-image=\"true\"></figure></a> 登录Cloudflare控制台,然后进入页面左侧的Zero Trust → Access→ 应用程序→ 创建一个应用程序 应用程序类型选择<strong>自托管</strong>, 公共主机名设置成我们上面的localpanel.merack.top <a href=\"https://cdn.merack.top/wp-content/uploads/2025/02/2237c155-dabc-96cc-23d0-848898dcb0d1.png\"><figure class=\"alignnone size-full wp-image-154\"><img loading=\"lazy\"  src=\"https://cdn.merack.top/wp-content/uploads/2025/02/2237c155-dabc-96cc-23d0-848898dcb0d1.png\" alt=\"\" width=\"1744\" height=\"729\" data-is-external-image=\"true\"></figure></a> <a href=\"https://cdn.merack.top/wp-content/uploads/2025/02/40fcceaa-b6f0-3887-8e25-934a00e92838.png\"><figure class=\"alignnone size-full wp-image-155\"><img  src=\"https://cdn.merack.top/wp-content/uploads/2025/02/40fcceaa-b6f0-3887-8e25-934a00e92838.png\" alt=\"\" width=\"1433\" height=\"734\" data-is-external-image=\"true\"></figure></a> 为了确保只能我们自己访问, 在页面下方我们新建一个访问策略 <a href=\"https://cdn.merack.top/wp-content/uploads/2025/02/ace8a9e5-5b49-3b04-0331-154f774657c0.png\"><figure class=\"alignnone size-full wp-image-156\"><img loading=\"lazy\"  src=\"https://cdn.merack.top/wp-content/uploads/2025/02/ace8a9e5-5b49-3b04-0331-154f774657c0.png\" alt=\"\" width=\"1422\" height=\"361\" data-is-external-image=\"true\"></figure></a> 访问策略里提供了相当多的规则, 这里我就选择emails, 表示只有规定的邮件地址才能进行验证, 然后在后方输入我们用于验证的email, 可以是多个, 可以不是注册cloudflare的邮箱. <a href=\"https://cdn.merack.top/wp-content/uploads/2025/02/034dcc47-bbda-f36e-7f5e-ccd61d6a2e28.png\"><figure class=\"alignnone wp-image-157\"><img  src=\"https://cdn.merack.top/wp-content/uploads/2025/02/034dcc47-bbda-f36e-7f5e-ccd61d6a2e28.png\" alt=\"\" width=\"803\" height=\"350\" data-is-external-image=\"true\"></figure></a> 添加完访问策略后回到应用程序配置页面进行选择 <a href=\"https://cdn.merack.top/wp-content/uploads/2025/02/f8e328ec-b7a8-8050-cdd4-4c67c8a1b746.png\"><figure class=\"alignnone size-full wp-image-158\"><img loading=\"lazy\"  src=\"https://cdn.merack.top/wp-content/uploads/2025/02/f8e328ec-b7a8-8050-cdd4-4c67c8a1b746.png\" alt=\"\" width=\"1428\" height=\"323\" data-is-external-image=\"true\"></figure></a> 然后一直点击下一步来到高级设置, 打开浏览器呈现 <a href=\"https://cdn.merack.top/wp-content/uploads/2025/02/cabdd2ab-1c03-d022-c13d-b2790311bb27.png\"><figure class=\"alignnone wp-image-159\"><img  src=\"https://cdn.merack.top/wp-content/uploads/2025/02/cabdd2ab-1c03-d022-c13d-b2790311bb27.png\" alt=\"\" width=\"768\" height=\"570\" data-is-external-image=\"true\"></figure></a> 这里是设置告诉cloudflare渲染什么样的界面, 有vnc和ssh, 这里我们选择ssh <a href=\"https://cdn.merack.top/wp-content/uploads/2025/02/4be9ab49-c0ed-6e11-ee61-b982676a78a6.png\"><figure class=\"alignnone size-full wp-image-160\"><img loading=\"lazy\"  src=\"https://cdn.merack.top/wp-content/uploads/2025/02/4be9ab49-c0ed-6e11-ee61-b982676a78a6.png\" alt=\"\" width=\"801\" height=\"463\" data-is-external-image=\"true\"></figure></a> 点击完成后web ssh应用程序就完成了, 这时我们打开为应用程序配置的公共域名localpanel.merack.top就会自动跳转到cloudflare access的验证页面, 这里只有填入我们刚才在访问策略里配置的邮箱地址才能收到cloudflare access的验证码 <a href=\"https://cdn.merack.top/wp-content/uploads/2025/02/ac556357-4b41-4b28-714a-1a50ca8b7d92.png\"><figure class=\"alignnone wp-image-161\"><img  src=\"https://cdn.merack.top/wp-content/uploads/2025/02/ac556357-4b41-4b28-714a-1a50ca8b7d92.png\" alt=\"\" width=\"698\" height=\"607\" data-is-external-image=\"true\"></figure></a> 验证完后就可以在浏览器中对内网服务器进行ssh操作了. <a href=\"https://cdn.merack.top/wp-content/uploads/2025/02/f333e931-b0ea-bd89-514f-34bddadc5db3.png\"><figure class=\"alignnone size-full wp-image-166\"><img loading=\"lazy\"  src=\"https://cdn.merack.top/wp-content/uploads/2025/02/f333e931-b0ea-bd89-514f-34bddadc5db3.png\" alt=\"\" width=\"728\" height=\"304\" data-is-external-image=\"true\"></figure></a> 此外访问策略也可用于上文提到的用ssh 命令行连接的方式, cloudflared会自动在浏览器拉起验证页面</p>\n<h3>优选IP加速访问</h3>\n<figure class=\"alignnone size-full wp-image-162\">cloudflare tunnels是建立在cloudflare的全球cdn节点上的, 但是cloudflare为ssh连接域名分配的默认泛播ip在国内体验不太好, 为了提升tunnels的连接体验, 我们可以手动修改hosts文件让ssh公共连接域名使用优选的ip节点. cloudflare优选ip网上的教程有很多, 最简单的就是直接ping我的博客域名: www.merack.top, 我的博客使用了SaaS, 这个域名会根据不同运营商返回优选好的ip. <a href=\"https://cdn.merack.top/wp-content/uploads/2025/02/865245cc-4d43-15d3-9be7-679b98cfade3.png\"><img loading=\"lazy\"  src=\"https://cdn.merack.top/wp-content/uploads/2025/02/865245cc-4d43-15d3-9be7-679b98cfade3.png\" alt=\"\" width=\"615\" height=\"176\" data-is-external-image=\"true\"></figure></a> 比如windows上的hosts文件在C:\\Windows\\System32\\drivers\\etc\\hosts, 那么我们可以做如下修改:</p>\n<figure class=\"alignnone size-full wp-image-163\"><a href=\"https://cdn.merack.top/wp-content/uploads/2025/02/6d4f2dc3-4db8-44c6-0d8b-ed0db2497af8.png\"><img loading=\"lazy\"  src=\"https://cdn.merack.top/wp-content/uploads/2025/02/6d4f2dc3-4db8-44c6-0d8b-ed0db2497af8.png\" alt=\"\" width=\"606\" height=\"235\" data-is-external-image=\"true\"></figure></a></p>\n<p>保存好后重新进行连接应该体验会有所改善</p>\n<h2>限制</h2>\n<figure class=\"alignnone size-full wp-image-164\">因为在服务端ssh连接是通过的本地cloudflared, 所以ssh server看到的连接ip都是来自127.0.0.1, 那么像 <a href=\"https://github.com/fail2ban/fail2ban\">fail2ban</a> 这种基于连接ip的工具可能会失去其效果. <a href=\"https://cdn.merack.top/wp-content/uploads/2025/02/5d828a3b-88e1-07a7-04e9-ca18e57be167.png\"><img  src=\"https://cdn.merack.top/wp-content/uploads/2025/02/5d828a3b-88e1-07a7-04e9-ca18e57be167.png\" alt=\"\" width=\"605\" height=\"143\" data-is-external-image=\"true\"></figure></a> 但是可以通过配合zero trust里的访问策略来对密码爆破做一定限制, 比如可以配置一个与前文提到的网页版ssh的同款访问策略, 那么在你使用ssh命令连接时, cloudflared会自动拉起浏览器打开cloudflare access验证窗口, 通过验证后才能进行后续的操作. <a href=\"https://cdn.merack.top/wp-content/uploads/2025/02/6c86edfb-c156-2ff2-26c9-de606c714f19.png\"><figure class=\"alignnone size-full wp-image-165\"><img loading=\"lazy\"  src=\"https://cdn.merack.top/wp-content/uploads/2025/02/6c86edfb-c156-2ff2-26c9-de606c714f19.png\" alt=\"\" width=\"1220\" height=\"265\" data-is-external-image=\"true\"></figure></a></p>",
            "author": {
                "name": "Merack"
            },
            "tags": [
            ],
            "date_published": "2025-02-28T23:58:53+08:00",
            "date_modified": "2025-02-28T23:58:53+08:00"
        },
        {
            "id": "https://blog.merack.top/windowsmingw-w64lsp-clangdvscodesublime-pei-zhi-jian-dan-ccpp-dan-wen-jian-xue-xi-huan-jing-jian-yao-ji-lu.html",
            "url": "https://blog.merack.top/windowsmingw-w64lsp-clangdvscodesublime-pei-zhi-jian-dan-ccpp-dan-wen-jian-xue-xi-huan-jing-jian-yao-ji-lu.html",
            "title": "Windows+MinGW-w64+lsp-clangd+VSCode/sublime 配置简单c/cpp 单文件学习环境简要记录",
            "summary": "有些时候我只想快速打开或者编写运行一个简单的c/cpp文件来快速验证想法, 比如说在做LeetCode上面的算法题时, 往往只需一个简单的单文件就可以写完所有逻辑. 我希望可以在编辑器里写代码时提供语法高亮, 智能提示, 错误检测和修改建议等功能, 同时还可以很方便地编译运行查看结果. 当前几乎所有的IDE都提供这些功能, 但是无论有多少个cpp文件, 里面的代码有多简单,&hellip;",
            "content_html": "<p>有些时候我只想快速打开或者编写运行一个简单的c/cpp文件来快速验证想法, 比如说在做LeetCode上面的算法题时, 往往只需一个简单的单文件就可以写完所有逻辑.</p>\n<p>我希望可以在编辑器里写代码时提供语法高亮, 智能提示, 错误检测和修改建议等功能, 同时还可以很方便地编译运行查看结果. 当前几乎所有的IDE都提供这些功能, 但是无论有多少个cpp文件, 里面的代码有多简单, 他们都要求新建一个工程项目来放置cpp文件, 对于我前面提到的场景有点\"杀鸡焉用牛刀了\".</p>\n<figure class=\"alignnone size-full wp-image-123\">后来我发现了<a href=\"https://microsoft.github.io/language-server-protocol/\">LSP</a>和<a href=\"https://github.com/llvm/llvm-project/tree/main/clang-tools-extra/clangd\">clangd</a>, 提供IDE的基本编码功能且轻量快速, 也支持单文件, 很符合我的需求. 安装clangd插件很简单不做介绍, 这里主要讲一下目前clangd在Windows上的一些问题: 目前clangd在Windows上只能自动识别MSVC的头文件, 但是如果没有安装MSVC而是用MinGW的GCC的话, 会报'vector file not found'等找不到头文件的错误. <a href=\"https://cdn.merack.top/wp-content/uploads/2024/12/95d69c25-3c8a-2874-6a45-33a745a76d9f.png\"><img  src=\"https://cdn.merack.top/wp-content/uploads/2024/12/95d69c25-3c8a-2874-6a45-33a745a76d9f.png\" alt=\"\" width=\"814\" height=\"511\" data-wp-editing=\"1\" data-is-external-image=\"true\"></figure></a> <a href=\"https://cdn.merack.top/wp-content/uploads/2024/12/03250458-cec3-3e99-0b09-27f0da1c3784.png\"><figure class=\"alignnone size-full wp-image-124\"><img loading=\"lazy\"  src=\"https://cdn.merack.top/wp-content/uploads/2024/12/03250458-cec3-3e99-0b09-27f0da1c3784.png\" alt=\"\" width=\"705\" height=\"705\" data-is-external-image=\"true\"></figure></a> 同样在Sublime Text上也会有类似的提示 <a href=\"https://cdn.merack.top/wp-content/uploads/2024/12/a3ea97d6-ad99-c593-e662-bec24e7849fc.png\"><figure class=\"alignnone size-full wp-image-125\"><img  src=\"https://cdn.merack.top/wp-content/uploads/2024/12/a3ea97d6-ad99-c593-e662-bec24e7849fc.png\" alt=\"\" width=\"834\" height=\"495\" data-is-external-image=\"true\"></figure></a> 上述问题通过Visual Studio Installer 安装MSVC就可以解决. 但是如果嫌msvc太大而只想用mingw呢? VSCode的clangd插件的GitHub仓库里正好有人提到了相关的issue: <a href=\"https://github.com/clangd/vscode-clangd/issues/478\">https://github.com/clangd/vscode-clangd/issues/478</a> . 根据issue里提到的方案, 只要加上<code>--target x86_64-w64-windows-gnu</code> 这个flag就可以了 <a href=\"https://cdn.merack.top/wp-content/uploads/2024/12/780fdbd7-0012-2874-6380-8f298ee479c8.png\"><figure class=\"alignnone size-full wp-image-126\"><img loading=\"lazy\"  src=\"https://cdn.merack.top/wp-content/uploads/2024/12/780fdbd7-0012-2874-6380-8f298ee479c8.png\" alt=\"\" width=\"1163\" height=\"368\" data-is-external-image=\"true\"></figure></a> 下面分别记录了VSCode和Sublime Text如何添加这个flag来解决在clangd在mingw下找不到头文件的问题以及分别通过其他插件快速编译运行cpp单文件</p>\n<h2>1. vscode + <a href=\"https://marketplace.visualstudio.com/items?itemName=llvm-vs-code-extensions.vscode-clangd\">clangd</a> + <a href=\"https://marketplace.visualstudio.com/items?itemName=formulahendry.code-runner\">Code Runner</a></h2>\n<ol>\n<li>在设置里搜索<code>@ext:llvm-vs-code-extensions.vscode-clangd</code></li>\n<li>在Fallback Flags里添加两个item, 一个是<code>--target</code>, 一个是<code>x86_64-w64-windows-gnu</code>, 如下图 <a href=\"https://cdn.merack.top/wp-content/uploads/2024/12/73c3768f-f408-050a-eea1-90dc100e829a.png\"><figure class=\"alignnone size-full wp-image-127\"><img loading=\"lazy\"  src=\"https://cdn.merack.top/wp-content/uploads/2024/12/73c3768f-f408-050a-eea1-90dc100e829a.png\" alt=\"\" width=\"961\" height=\"348\" data-is-external-image=\"true\"></figure></a></li>\n</ol>\n<figure class=\"alignnone size-full wp-image-128\">这时重开VSCode就会发现clangd可以找到mingw的头文件了 <a href=\"https://cdn.merack.top/wp-content/uploads/2024/12/136d4c84-0290-0412-b66a-8579e3a47880.png\"><img  src=\"https://cdn.merack.top/wp-content/uploads/2024/12/136d4c84-0290-0412-b66a-8579e3a47880.png\" alt=\"\" width=\"875\" height=\"505\" data-is-external-image=\"true\"></figure></a> 然后再安装 Code Runner 插件就可以通过右键-&gt;Run Code来直接运行cpp单文件了 <a href=\"https://www.merack.top/wp-content/uploads/2024/11/screenshot_2024_0818_09-33-42.png\"><figure class=\"alignnone size-full wp-image-78\"><img loading=\"lazy\"  src=\"https://www.merack.top/wp-content/uploads/2024/11/screenshot_2024_0818_09-33-42.png\" alt=\"\" width=\"1390\" height=\"132\" data-is-external-image=\"true\"></figure></a></p>\n<h2>2. sublime text+ <a href=\"https://github.com/sublimelsp/LSP-clangd\">LSP-clangd</a> + <a href=\"https://github.com/Jatana/FastOlympicCoding\">FastOlympicCoding</a></h2>\n<ol>\n<li>以此通过上方菜单栏的Preferences-&gt;Package Settings-&gt;LSP-&gt;Servers-&gt;LSP-cland打开cland的配置文件</li>\n<li>将initializationOptions这一个字段的内容复制到自定义配置里并且修改<code>fallbackFlags</code> 这一个字段:\n<pre>\"fallbackFlags\": [\"-target\", \"x86_64-w64-windows-gnu\"],</pre>\n如图所示: <a href=\"https://cdn.merack.top/wp-content/uploads/2024/12/9a4890d7-c650-cd8a-e5a3-0cbc785da01b.png\"><figure class=\"alignnone size-full wp-image-129\"><img loading=\"lazy\"  src=\"https://cdn.merack.top/wp-content/uploads/2024/12/9a4890d7-c650-cd8a-e5a3-0cbc785da01b.png\" alt=\"\" width=\"856\" height=\"441\" data-is-external-image=\"true\"></figure></a></li>\n</ol>\n<figure class=\"alignnone size-full wp-image-130\">这时重开Sublime Text就会发现clangd可以找到mingw的头文件了 <a href=\"https://cdn.merack.top/wp-content/uploads/2024/12/f9ce493b-9c15-1788-69a5-77f1de766aea.png\"><img  src=\"https://cdn.merack.top/wp-content/uploads/2024/12/f9ce493b-9c15-1788-69a5-77f1de766aea.png\" alt=\"\" width=\"1175\" height=\"470\" data-is-external-image=\"true\"></figure></a> 然后再安装 FastOlympicCoding 插件就可以通过ctrl+alt+b来直接运行cpp单文件了 <a href=\"https://cdn.merack.top/wp-content/uploads/2024/12/8fa642d2-d406-293d-911f-a15b54f36ee3.png\"><figure class=\"alignnone size-full wp-image-131\"><img loading=\"lazy\"  src=\"https://cdn.merack.top/wp-content/uploads/2024/12/8fa642d2-d406-293d-911f-a15b54f36ee3.png\" alt=\"\" width=\"614\" height=\"285\" data-is-external-image=\"true\"></figure></a></p>\n<p>同时记得要在FastOlympicCoding 配置文件里设置<code>lint_enabled</code>和<code>cpp_complete_enabled</code>为<code>false</code>, 不然可能会与clangd插件冲突</p>\n<h2>3.不足</h2>\n<p>最大的不足就是没有debug功能, 要看某些变量在运行过程的变化只能通过类似printf来输出. 要是遇到了需要debug的情况, 还是推荐使用IDE来新建项目.另外VSCode的<a href=\"https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools\">官方cpp插件</a>是带有简单的调试功能的, 但是性能会比clangd差很多, 各有取舍吧.</p>",
            "author": {
                "name": "Merack"
            },
            "tags": [
            ],
            "date_published": "2024-12-21T20:19:21+08:00",
            "date_modified": "2024-12-21T20:24:08+08:00"
        },
        {
            "id": "https://blog.merack.top/wordpress-an-quan-fang-hu-jian-dan-ji-lu.html",
            "url": "https://blog.merack.top/wordpress-an-quan-fang-hu-jian-dan-ji-lu.html",
            "title": "WordPress 安全防护简单记录",
            "summary": "WordPress网站一直是被恶意程序扫描和密码爆破的重灾区, 每次一查Nginx日志都能看到一大堆对本博客的密码撞库攻击和敏感路径扫描 在几年前由于用了弱密码还真被爆破成功, 虽然很快我就改了密码. 但由于不确定是否有被留下暗桩, 索性重装了一遍系统, 都是血泪教训. 随着跑在服务器上的业务越来越多, 重装的代价已经是非常大了. 所以从那次事故以后我便开始留意WordPress的安全问题,&hellip;",
            "content_html": "<figure class=\"alignnone size-full wp-image-90\">WordPress网站一直是被恶意程序扫描和密码爆破的重灾区, 每次一查Nginx日志都能看到一大堆对本博客的密码撞库攻击和敏感路径扫描 <a href=\"https://cdn.merack.top/wp-content/uploads/2024/12/9b08f457-b2a4-5f21-d949-5a2b0acc872d.png\"><img  src=\"https://cdn.merack.top/wp-content/uploads/2024/12/9b08f457-b2a4-5f21-d949-5a2b0acc872d.png\" alt=\"\" width=\"788\" height=\"323\" data-is-external-image=\"true\"></figure></a> <a href=\"https://cdn.merack.top/wp-content/uploads/2024/12/5486867a-cf9d-feff-1934-2d0d6466e649.png\"><figure class=\"alignnone size-full wp-image-86\"><img loading=\"lazy\"  src=\"https://cdn.merack.top/wp-content/uploads/2024/12/5486867a-cf9d-feff-1934-2d0d6466e649.png\" alt=\"\" width=\"1908\" height=\"796\" data-is-external-image=\"true\"></figure></a> 在几年前由于用了弱密码还真被爆破成功, 虽然很快我就改了密码. 但由于不确定是否有被留下暗桩, 索性重装了一遍系统, 都是血泪教训. 随着跑在服务器上的业务越来越多, 重装的代价已经是非常大了. 所以从那次事故以后我便开始留意WordPress的安全问题, 下面是我这些年来做过的配置的一些简单记录.</p>\n<h2>1. WordPress插件篇</h2>\n<figure class=\"alignnone size-full wp-image-87\">WordPress推荐使用插件 <a href=\"https://cn.wordpress.org/plugins/login-lockdown/\">Login Lockdow</a> 的登录验证码功能, 类型直接选择built-in Captcha即刻, 亲测可以抵挡99%的密码撞库攻击 <a href=\"https://cdn.merack.top/wp-content/uploads/2024/12/76a96c65-1ce4-0d1a-246e-195ccd5196d2.png\"><img  src=\"https://cdn.merack.top/wp-content/uploads/2024/12/76a96c65-1ce4-0d1a-246e-195ccd5196d2.png\" alt=\"\" width=\"1465\" height=\"688\" data-is-external-image=\"true\"></figure></a> 可以看到登录失败的全是给验证码拦截了 <a href=\"https://cdn.merack.top/wp-content/uploads/2024/12/728b31a3-18d1-60cc-e079-6f9595280706.png\"><figure class=\"alignnone size-full wp-image-88\"><img loading=\"lazy\"  src=\"https://cdn.merack.top/wp-content/uploads/2024/12/728b31a3-18d1-60cc-e079-6f9595280706.png\" alt=\"\" width=\"1504\" height=\"598\" data-is-external-image=\"true\"></figure></a> WordPress上还有很多更加全面的安全插件, 但过多或者过于复杂的插件会减慢站点速度, 特别是我现在用这个小鸡性能一般, 因此我会更倾向在下面几个方面来做后续的防护.</p>\n<h2>2.Nginx篇</h2>\n<p>在Nginx上我主要是对WordPress中的一些敏感路径进行访问限制, 主要配置如下</p>\n<div>\n<pre>   #禁止以. 开头的文件访问, 如.htaccess, .htpasswd, .DS_Store (Mac).\n    location ~ /\\. {\n        deny all;\n    }\n\n    #禁止访问路径 /xmlrpc.php\n    location ~ /xmlrpc.php$ {\n        deny all;\n    }\n\n    #禁止访问路径 /wp-json/wp/v2/users\n    location ~ ^/wp-json/wp/v2/users {\n        deny all;\n    }\n\n    #禁止访问路径 /wp-includes/wlwmanifest.xml\n    location ~ ^/wp-includes/wlwmanifest.xml {\n        deny all;\n    }\n\n    #禁止直接访问uploads和files文件夹下的php文件\n    location ~ /(?:uploads|files)/.*\\.php$ {\n        deny all;\n    }</pre>\n</div>\n<div>其中<code>/xmlrpc.php</code>是除了/wp-login.php 之外的另一种可以被用来验证后台密码的方式, 因此也经常会被利用来做密码撞库;</div>\n<div><code>/wp-json/wp/v2/users</code> 会返回后台管理员的登录用户名, 建议禁止并且不要将管理员登录名设置成Admin这种常见的形式;</div>\n<div><code>/wp-includes/wlwmanifest.xml</code> 是我在别的博客看到的, 但是新版WordPress好像移除了这个文件, 反正我用的版本目录下没有, 关于这个文件的限制可以不写, 最重要的还是前面两个路径.</div>\n<h2>3.CDN篇</h2>\n<p>如果你的网站套了CDN的话, 可以通过CDN里提供的一些配置来相关的防护. 不同CDN提供商的功能都有所不同, 这里我主要记录我正在用的两家CDN的配置.</p>\n<h3>3.1 又拍云</h3>\n<figure class=\"alignnone size-full wp-image-89\">在CDN的访问控制选项下又拍云提供了网站安全防护的基本功能, 我主要用到的是 IP 访问限制 和 WAF保护 这两个. ip访问限制可以对敏感路径设置一个阈值, 如果某个ip在短时间内对该路径的请求超过该阈值, 那么它可能是在做密码撞库, 这时就会禁止他的访问请求. 我的配置如下 <a href=\"https://cdn.merack.top/wp-content/uploads/2024/12/b671f607-2ba8-fac4-b8a3-6bfcadeb8430.png\"><img loading=\"lazy\"  src=\"https://cdn.merack.top/wp-content/uploads/2024/12/b671f607-2ba8-fac4-b8a3-6bfcadeb8430.png\" alt=\"\" width=\"1373\" height=\"392\" data-is-external-image=\"true\"></figure></a> 我的阈值设置成20次/分, 封禁时间是8400秒, 可以多观察网站的访问日志, 根据自己的情况来设置. 建议在上方的ip白名单中加入自己的ip防止误杀.</p>\n<p>此外, 又拍云还提供了 WAF保护, 但是只有一个功能开关, 不能配置规则, 也没有分析统计, 在这方面不如Cloudflare. 这项配置没什么好说的, 打开就好.</p>\n<h3>3.2 Cloudflare</h3>\n<p>相较于又拍云, Cloudflare提供的安全防护就全面了很多. 提供了WAF, DDoS防护, 页面规则等一系列功能, 其中WAF是可以自己写规则的, 可以说是非常丰富了. 我在Cloudflare上的安全配置基本都是在WAF里, 下面是我写的一些规则:</p>\n<p><strong>第一条</strong>是专门为WordPress写的, 一是阻止WordPress的敏感路径扫描,二是阻止规定以外的ip进行登录请求</p>\n<pre>(http.host wildcard \"merack.top\") and ((cf.waf.credential_check.password_leaked) or (http.request.uri.path wildcard r\"/wp-login.php\" and (ip.geoip.country ne \"CN\" and (not ip.src in {192.168.1.1}))) or ((http.request.uri.path wildcard r\"/xmlrpc.php\") or (http.request.uri.path wildcard r\"/wp-json/wp/v2/users\"))) \n</pre>\n<p><code>http.host wildcard \"merack.top\"</code> 表示只匹配对merack.top的访问;</p>\n<p><code>cf.waf.credential_check.password_leaked</code> 表示cf会检测登录请求中的密码是否是已知的通过各种信息泄露事件泄露过的密码, 具体描述可以看Cloudflare官方的这篇文档, 不少自动程序除了尝试弱密码组合之外还会尝试泄露过的数据库中的密码; http.request.uri.path wildcard r\"/wp-login.php\" 表示匹配访问路径是/wp-login.php的请求;</p>\n<p><code>ip.geoip.country ne \"CN\" and (not ip.src in {192.168.1.1})</code> 表示匹配请求ip不是来自中国的并且不在受信任ip里的(这里以192.168.1.1)为例, 建议将正在托管WordPress的服务器ip加入到列表中, 因为通过Nginx日志观察, WordPress会定时请求自身来触发一些定时任务(比如/wp-login.php), 如果你的服务器ip恰好不在中国内又不在信任ip列表中, 那么可能会被拦截, 也可以在这条waf规则前再写一条白名单规则放行; </p>\n<p><code>(http.request.uri.path wildcard r\"/xmlrpc.php\") or (http.request.uri.path wildcard r\"/wp-json/wp/v2/users\")</code> 表示匹配这两个敏感路径的请求, 这两个路径在前面已经做过介绍.</p>\n<p>最后将这几个匹配条件按照相应的逻辑通过and 和 or 连接起来, 大概如下图</p>\n<figure class=\"alignnone size-full wp-image-91\"><a href=\"https://cdn.merack.top/wp-content/uploads/2024/12/e024a11d-1bc1-49c0-2ce5-b9c820a969a6.png\" style=\"font-family: var(--editor-font-family); font-size: inherit; font-weight: var(--font-weight-normal);\"><img  src=\"https://cdn.merack.top/wp-content/uploads/2024/12/e024a11d-1bc1-49c0-2ce5-b9c820a969a6.png\" alt=\"\" width=\"1345\" height=\"680\" data-is-external-image=\"true\"></figure></a><span style=\"color: var(--text-primary-color); font-family: var(--editor-font-family); font-size: inherit; font-weight: var(--font-weight-normal);\"> 效果还是很可观的 </span><a href=\"https://cdn.merack.top/wp-content/uploads/2024/12/2b48a6ef-e98f-d323-caa8-b18f104aa1c3.png\" style=\"font-family: var(--editor-font-family); font-size: inherit; font-weight: var(--font-weight-normal);\"><figure class=\"alignnone size-full wp-image-92\"><img loading=\"lazy\"  src=\"https://cdn.merack.top/wp-content/uploads/2024/12/2b48a6ef-e98f-d323-caa8-b18f104aa1c3.png\" alt=\"\" width=\"1252\" height=\"724\" data-is-external-image=\"true\"></figure></a><span style=\"color: var(--text-primary-color); font-family: var(--editor-font-family); font-size: inherit; font-weight: var(--font-weight-normal);\"> </span></p>\n<figure class=\"alignnone size-full wp-image-94\"><strong style=\"font-family: var(--editor-font-family); font-size: inherit;\">第二条</strong><span style=\"color: var(--text-primary-color); font-family: var(--editor-font-family); font-size: inherit; font-weight: var(--font-weight-normal);\">规则是对域名下的所有站点都生效的, 主要是防止除了已知的搜索引擎的蜘蛛机器人之外的其他自动程序和高风险IP对站点进行扫描, 这里的逻辑比较简单, 直接用可视化的表达式生成器即可: </span><a href=\"https://cdn.merack.top/wp-content/uploads/2024/12/3707771e-3617-5d48-49a0-1bb4679e2e2b.png\" style=\"font-family: var(--editor-font-family); font-size: inherit; font-weight: var(--font-weight-normal);\"><img loading=\"lazy\"  src=\"https://cdn.merack.top/wp-content/uploads/2024/12/3707771e-3617-5d48-49a0-1bb4679e2e2b.png\" alt=\"\" width=\"1329\" height=\"774\" data-is-external-image=\"true\"></figure></a><span style=\"color: var(--text-primary-color); font-family: var(--editor-font-family); font-size: inherit; font-weight: var(--font-weight-normal);\"> 与第一条规则不同, 这里没有指定 </span><code style=\"font-weight: var(--font-weight-normal);\">http.host wildcard \"merack.top\"</code><span style=\"color: var(--text-primary-color); font-family: var(--editor-font-family); font-size: inherit; font-weight: var(--font-weight-normal);\"> , 所以该条规则对域名下的所有子域名都有效.</span></p>\n<p><span style=\"color: var(--text-primary-color); font-family: var(--editor-font-family); font-size: inherit; font-weight: var(--font-weight-normal);\">图中的威胁分数是Cloudflare对ip的恶意程度进行的一个评估, 请求的威胁评分值为0到100, 其中0表示低风险. 大于10的值可能表示垃圾邮件发送者或机器人, 大于40的值表示互联网上的不良行为者, 很少有超过60的值. 详细描述可以参照官方的</span><a href=\"https://developers.cloudflare.com/ruleset-engine/rules-language/fields/dynamic-fields/#cfthreat_score\" style=\"font-family: var(--editor-font-family); font-size: inherit; font-weight: var(--font-weight-normal);\">这个文档</a><span style=\"color: var(--text-primary-color); font-family: var(--editor-font-family); font-size: inherit; font-weight: var(--font-weight-normal);\">.官方推荐设置大于10触发托管质询, 大于50直接block.</span></p>\n<p><span style=\"color: var(--text-primary-color); font-family: var(--editor-font-family); font-size: inherit; font-weight: var(--font-weight-normal);\">下面的选择操作-&gt;托管质询 是指Cloudflare会生成一个用于人机验证的验证页面, 通过验证才可以继续访问.</span></p>\n<figure class=\"alignnone size-full wp-image-95\"><span style=\"color: var(--text-primary-color); font-family: var(--editor-font-family); font-size: inherit; font-weight: var(--font-weight-normal);\">最后的规则总览 </span><a href=\"https://cdn.merack.top/wp-content/uploads/2024/12/8dfc073c-61b8-c22e-5218-f564ac2b3580.png\" style=\"font-family: var(--editor-font-family); font-size: inherit; font-weight: var(--font-weight-normal);\"><img loading=\"lazy\"  src=\"https://cdn.merack.top/wp-content/uploads/2024/12/8dfc073c-61b8-c22e-5218-f564ac2b3580.png\" alt=\"\" width=\"1341\" height=\"573\" data-is-external-image=\"true\"></figure></a><span style=\"color: var(--text-primary-color); font-family: var(--editor-font-family); font-size: inherit; font-weight: var(--font-weight-normal);\"> 执行质询类的操作都会自动计算一个CRS值, 这个值可以体现质询规则的有效性, 越低表示误杀的真实用户越少, 则效果越好.<br>如果在CSR为0的同时Nginx日志中还有大量的路径扫描请求记录, 那么可以尝试降低威胁分数的值, 也有可能是这些IP未被收录在Cloudflare的数据库中所以不触发质询, 总之这个要慢慢调, 防扫描我还在学习中. 这条规则我也是刚写等待后面的测试.</span></p>",
            "author": {
                "name": "Merack"
            },
            "tags": [
            ],
            "date_published": "2024-12-03T16:08:29+08:00",
            "date_modified": "2024-12-05T12:03:54+08:00"
        },
        {
            "id": "https://blog.merack.top/shi-yong-you-pai-yun-jia-su-wordpresshou-tai-yang-shi-shi-xiao-hou-tai-cai-dan-gong-neng-dian-ji-wu-fan-ying-jie-jue-fang-fa-ji-jian-yao-pei-zhi.html",
            "url": "https://blog.merack.top/shi-yong-you-pai-yun-jia-su-wordpresshou-tai-yang-shi-shi-xiao-hou-tai-cai-dan-gong-neng-dian-ji-wu-fan-ying-jie-jue-fang-fa-ji-jian-yao-pei-zhi.html",
            "title": "使用又拍云加速WordPress简要配置, 解决后台样式失效, 后台功能点击无反应问题",
            "summary": "之前写了一篇又拍云加速静态网站GitHub Pages的文章, 现在这篇文章就来介绍一下又拍云加速动态网站WordPress的配置以及遇到的一些坑. 又拍云为开发者提供每月免费额度, 可以到下面的链接注册申请: 服务的创建, CNAME绑定和一些基本的配置可以参考我的上一篇文章, 但是有一些CDN的配置要做出调整, 否则会造成网站异常, 主要是在后台页面.",
            "content_html": "<p>之前写了一篇<a href=\"https://blog.merack.top/yong-you-pai-yun-zuo-wei-cdnjia-su-github-pagesjian-yao-pei-zhi-ji-lu-2.html\" target=\"_blank\" rel=\"noopener noreferrer\">又拍云加速静态网站GitHub Pages</a>的文章, 现在这篇文章就来介绍一下又拍云加速动态网站WordPress的配置以及遇到的一些坑. 又拍云为开发者提供每月免费额度, 可以到下面的链接注册申请: </p>\n<ol>\n<li>又拍云账号: <a href=\"https://console.upyun.com/register/?invite=SJxy8d1Sw\" target=\"_blank\" rel=\"noopener\">点我注册</a></li>\n<li>注册完毕后可以到 <a href=\"https://www.upyun.com/?utm_source=lianmeng&amp;utm_medium=referral\" target=\"_blank\" rel=\"noopener\">又拍云联盟</a>页面按要求申请开发者每月免费配额</li>\n</ol>\n<p>服务的创建, CNAME绑定和一些基本的配置可以参考我的上一篇文章, 但是有一些CDN的配置要做出调整, 否则会造成网站异常, 主要是在后台页面. 下面是我是用过程中遇到的一些坑.</p>\n<h2>1. 后台菜单功能点击无反应, 功能异常</h2>\n<figure class=\"alignnone size-full wp-image-58\">原因是又拍云默认规则是忽略URL '?' 后面的的参数. 但是如下图所示, WordPress后台功能基本上都是需要通过URL传进来的参数才能正常工作的 <a href=\"https://cdn.merack.top/wp-content/uploads/2024/06/微信截图_20190215001806.png\"><img  src=\"https://cdn.merack.top/wp-content/uploads/2024/06/微信截图_20190215001806.png\" alt=\"\" width=\"699\" height=\"437\" data-is-external-image=\"true\"></figure></a> <a href=\"https://cdn.merack.top/wp-content/uploads/2024/06/微信截图_20190215001941.png\"><figure class=\"alignnone size-full wp-image-59\"><img loading=\"lazy\"  src=\"https://cdn.merack.top/wp-content/uploads/2024/06/微信截图_20190215001941.png\" alt=\"\" width=\"761\" height=\"500\" data-is-external-image=\"true\"></figure></a> 解决方法是在缓存控制选项卡下的参数跟随中选择全程跟随, 这样流量流经CDN时就不会去掉后面的参数, 源站就能正确接受到前端发过来的参数 <a href=\"https://cdn.merack.top/wp-content/uploads/2024/06/screenshot_2024_0619_10-08-28.png\"><figure class=\"alignnone size-full wp-image-61\"><img loading=\"lazy\"  src=\"https://cdn.merack.top/wp-content/uploads/2024/06/screenshot_2024_0619_10-08-28.png\" alt=\"\" width=\"1411\" height=\"348\" data-is-external-image=\"true\"></figure></a></p>\n<h2>2. 后台样式失效</h2>\n<p>如果你的WordPress站主页正常但是后台页面样式丢失, 并且控制台报了很多/wp-admin/load-scripts.php 加载的js的错误, 那么就要去调整又拍云的缓存规则. 虽说又拍云自己声称可以自动分辨处理动静态资源, 同时加速动静态请求, 但目前来看又拍云对于WordPress 的load-scripts.php动态加载的js的处理还存在问题. 为了防止动态请求出现奇奇怪怪的问题, 我们直接将以下两个包含WordPress核心代码文件的目录加入到缓存控制-&gt;缓存配置的 <span style=\"color: #f1c40f;\"><strong>不缓存规则</strong></span> 中</p>\n<pre>/wp-includes/*\n/wp-admin/*</pre>\n<figure class=\"alignnone size-full wp-image-60\"><a href=\"https://cdn.merack.top/wp-content/uploads/2024/06/screenshot_2024_0619_10-33-08.png\"><img  src=\"https://cdn.merack.top/wp-content/uploads/2024/06/screenshot_2024_0619_10-33-08.png\" alt=\"\" width=\"1366\" height=\"473\" data-is-external-image=\"true\"></figure></a> 处理完成后强烈建议在CDN服务管理页点击一次全站刷新, 让CDN节点上旧的缓存过期 <a href=\"https://cdn.merack.top/wp-content/uploads/2024/06/screenshot_2024_0619_10-39-08.png\"><figure class=\"alignnone size-full wp-image-62\"><img loading=\"lazy\"  src=\"https://cdn.merack.top/wp-content/uploads/2024/06/screenshot_2024_0619_10-39-08.png\" alt=\"\" width=\"1304\" height=\"420\" data-is-external-image=\"true\"></figure></a></p>",
            "author": {
                "name": "Merack"
            },
            "tags": [
            ],
            "date_published": "2024-06-19T20:48:00+08:00",
            "date_modified": "2024-06-23T12:40:09+08:00"
        },
        {
            "id": "https://blog.merack.top/ubuntu2404an-zhuang-mysql80yu-dao-de-yi-xie-wen-ti-shu-ju-ku-rootzhang-hu-she-zhi-mi-ma-wu-xiao-rootzhang-hu-wu-xu-mi-ma-huo-mi-ma-cuo-wu-du-ke-deng-lu-yi-ji-qi-ta-cao-zuo-ji-lu.html",
            "url": "https://blog.merack.top/ubuntu2404an-zhuang-mysql80yu-dao-de-yi-xie-wen-ti-shu-ju-ku-rootzhang-hu-she-zhi-mi-ma-wu-xiao-rootzhang-hu-wu-xu-mi-ma-huo-mi-ma-cuo-wu-du-ke-deng-lu-yi-ji-qi-ta-cao-zuo-ji-lu.html",
            "title": "解决Ubuntu安装MySQL8.0后 数据库root设置密码无效, root无需密码或密码错误都可登录",
            "summary": "Ubuntu24.04使用apt-get安装MySQL8.0后发现数据库的root账户竟然不用密码也能登录尝试随便输入一个密码也能登录, 使用 ALTER USER 'root'@'localhost' IDENTIFIED BY 'new passwd'; 语句修改密码后问题依然存在,&hellip;",
            "content_html": "<p>Ubuntu24.04使用apt-get安装MySQL8.0后发现数据库的root账户竟然不用密码也能登录<figure class=\"alignnone size-full wp-image-41\"><img loading=\"lazy\"  src=\"https://cdn.merack.top/wp-content/uploads/2024/06/screenshot_2024_0616_21-04-26.png\" alt=\"\" width=\"708\" height=\"279\" data-is-external-image=\"true\"></figure>尝试随便输入一个密码也能登录, 使用 ALTER USER 'root'@'localhost' IDENTIFIED BY 'new passwd'; 语句修改密码后问题依然存在, 以前使用MySQL5.7并未发现相关的问题.</p>\n<h3>原因</h3>\n<p>通过查找资料发现是MySQL8.0开始更改了root账户的默认密码验证插件为<a href=\"https://dev.mysql.com/doc/mysql-secure-deployment-guide/8.0/en/secure-deployment-configure-authentication.html\">auth_socket</a>导致的, 可以通过一下命令查看数据库中的用户使用的身份验证插件:</p>\n<pre>SELECT user, host, plugin FROM mysql.user;</pre>\n<figure class=\"alignnone size-full wp-image-43\"><img loading=\"lazy\"  src=\"https://cdn.merack.top/wp-content/uploads/2024/06/screenshot_2024_0616_21-32-04.png\" alt=\"\" width=\"535\" height=\"254\" data-is-external-image=\"true\"></figure><br>可以看到root使用的身份验证插件是auth_socket, 其他用户默认是caching_sha2_password. auth_socket这个插件是通过Unix socket文件来进行身份验证, 简单来说就是你在Linux系统的登录名为root, 那么当登录数据库的root账号时数据库会与系统进行socket通信, 发现要登录的用户名是相同的, 那么就会允许这次登录, 详细信息可以看MySQL的官方文档: <a href=\"https://dev.mysql.com/doc/mysql-secure-deployment-guide/8.0/en/secure-deployment-configure-authentication.html\">auth_socket</a> 以及这篇文章: <a href=\"https://segmentfault.com/a/1190000039860881\">https://segmentfault.com/a/1190000039860881</a><br>MySQL8.0以上将其作为root的默认身份插件有一定的道理, 首先, Unix socket通信只能是在本机的程序之间进行, 不会通过TCP/IP网络栈, 不用当心来自外部的爆破;  二是Linux本身的身份验证已经很完善, 用户如果能以root登录系统, 那么无论使用何种插件都能被轻易地修改密码.</p>\n<h3>更改身份验证插件</h3>\n<p>如果想用账户密码方式的身份验证, 可以通过以下语句更改, WITH 后面是身份验证插件名称, BY 后面是登录密码:</p>\n<pre>ALTER USER 'root'@'localhost' IDENTIFIED WITH caching_sha2_password BY 'new password';</pre>\n<figure class=\"alignnone size-full wp-image-43\"><img loading=\"lazy\"  src=\"https://cdn.merack.top/wp-content/uploads/2024/06/screenshot_2024_0616_21-53-04.png\" alt=\"\" width=\"797\" height=\"323\" data-is-external-image=\"true\"></figure>\n<p>可以看到root的身份验证插件已经改为caching_sha2_password<br>改完以后需要提供正确的密码才能登录<figure class=\"alignnone size-full wp-image-44\"><img loading=\"lazy\"  src=\"https://cdn.merack.top/wp-content/uploads/2024/06/screenshot_2024_0616_21-56-15.png\" alt=\"\" width=\"768\" height=\"98\" data-is-external-image=\"true\"></figure>需要注意的是, 有一些文章WITH 后面跟的是mysql_native_password, 但是根据官方文档: <a href=\"https://dev.mysql.com/doc/refman/8.0/en/native-pluggable-authentication.html\">https://dev.mysql.com/doc/refman/8.0/en/native-pluggable-authentication.html</a> 中的描述, mysql_native_password插件会在MySQL 8.0.34中弃用并且在后续版本中删除, 官方更推荐caching_sha2_password, 具有更好的安全性.</p>\n<h3>mysql_secure_installation</h3>\n<p>实际上, 根据MySQL官方文档\"安装后的设置与测试\"(<a href=\"https://dev.mysql.com/doc/refman/8.0/en/postinstallation.html\">Postinstallation Setup and Testing</a> )一节中的<a href=\"https://dev.mysql.com/doc/refman/8.0/en/default-privileges.html\">Securing the Initial MySQL Account</a> 小节里提到了mysql_secure_installation这个程序, 他随MySQL一同安装, 用于对MySQL安装后, 上线生产环境前的安全初始化, 其中主要包括以下功能:<br>1. 为root账户设置密码;<br>2. 禁止root账户远程访问;<br>3. 删除匿名账户;<br>4. 删除test数据库;</p>\n<p>如果你安装完MySQL后运行这个程序, 就能发现问题所在, 程序提示root用户正在使用auth_socket, 因此跳过密码设置, 所以平时还是要多看看文档^_^<figure class=\"alignnone size-full wp-image-45\"><img loading=\"lazy\"  src=\"https://cdn.merack.top/wp-content/uploads/2024/06/screenshot_2024_0616_22-45-39.png\" alt=\"\" width=\"1023\" height=\"320\" data-is-external-image=\"true\"></figure>\n<h3>内存优化</h3>\n<p>如果你的主机内存很小, 那么建议修改MySQL配置文件, 在 [mysqld] 下添加:<br><code>performance_schema = off</code><br>亲测可以减少100多M的内存, <code>performance_schema</code> 是用来记录MySQL查询性能相关的记录, 用于给数据库管理员做性能分析的, 如果你没有这方面的需求, 那么可以关闭它.</p>",
            "author": {
                "name": "Merack"
            },
            "tags": [
                   "Linux"
            ],
            "date_published": "2024-06-16T23:06:31+08:00",
            "date_modified": "2024-11-15T11:42:55+08:00"
        },
        {
            "id": "https://blog.merack.top/yong-you-pai-yun-zuo-wei-cdnjia-su-github-pagesjian-yao-pei-zhi-ji-lu-2.html",
            "url": "https://blog.merack.top/yong-you-pai-yun-zuo-wei-cdnjia-su-github-pagesjian-yao-pei-zhi-ji-lu-2.html",
            "title": "使用又拍云加速GitHub Pages简要配置",
            "summary": "<p>GitHub Pages为GitHub上的项目提供主页托管功能, 我们可以用它来托管我们的静态网站. 但是由于GitHub Pages服务器在国外, 因此在国内的访问速度可能不太理想.但是我们可以通过CDN来加速它的访问速度. 正巧又拍云推出了开发者计划, 为开发者提供每月10G的云存储和15G的CDN流量, 对于个人网站来说已经足够了. 下面是我为GitHub Pages配置又拍云CDN加速的一些简要配置记录.</p>\n",
            "content_html": "<p>GitHub Pages为GitHub上的项目提供主页托管功能, 我们可以用它来托管我们的静态网站. 但是由于GitHub Pages服务器在国外, 因此在国内的访问速度可能不太理想.但是我们可以通过CDN来加速它的访问速度. 正巧又拍云推出了开发者计划, 为开发者提供每月10G的云存储和15G的CDN流量, 对于个人网站来说已经足够了. 下面是我为GitHub Pages配置又拍云CDN加速的一些简要配置记录.</p>\n\n<h2 data-heading=\"必备条件\">必备条件</h2>\n<ol>\n<li>已经备案的域名(国内的CDN厂商基本都要求)</li>\n<li>又拍云账号: <a href=\"https://console.upyun.com/register/?invite=SJxy8d1Sw\" target=\"_blank\" rel=\"noopener noreferrer\">点我注册</a>, 注册完毕后可以到 <a href=\"https://www.upyun.com/?utm_source=lianmeng&amp;utm_medium=referral\" target=\"_blank\" rel=\"noopener noreferrer\">又拍云联盟</a>页面按要求申请开发者每月免费配额, 一般在自己网站挂一个又拍云的logo然后提交申请就可以了.需要注意的是, 当前你的网站是要有一定内容的不然不会通过(实测我的博客就发了三篇文章就申请通过了).</li>\n</ol>\n<h2 data-heading=\"简要配置\">简要配置</h2>\n<h3 data-heading=\"GitHub Pages设置\">GitHub Pages设置</h3>\n<p>静态网站如何生成不在本文讨论范围, 这里只讨论自定义域名相关话题. 在托管静态网站的GitHub仓库中点击Settings-&gt;Pages-&gt;Custom domain 中配置你已经备案的域名, 比如我这里是blog.merack.top. 需要注意的是如果你的page不是由GitHub Actions workflow生成的, 那么需要确认仓库根目录中有一个CNAME文件, 里面存储的是你自定义域名, 具体请看GitHub Pages的文档: <a rel=\"noopener\" class=\"external-link\" href=\"https://docs.github.com/en/pages/configuring-a-custom-domain-for-your-github-pages-site/troubleshooting-custom-domains-and-github-pages#cname-errors\" target=\"_blank\">https://docs.github.com/en/pages/configuring-a-custom-domain-for-your-github-pages-site/troubleshooting-custom-domains-and-github-pages#cname-errors</a></p>\n<h3 data-heading=\"又拍云设置\">又拍云设置</h3>\n<h4 data-heading=\"创建服务\">创建服务</h4>\n<p>在又拍云创建CDN服务, 加速域名填你已备案的自定义域名, 应用场景选网页图片, 实际上根据<a data-tooltip-position=\"top\" aria-label=\"https://help.upyun.com/knowledge-base/%e6%8e%a7%e5%88%b6%e5%8f%b0%e6%9c%8d%e5%8a%a1%e9%85%8d%e7%bd%ae/#1-e68891e683b3e4bfaee694b9e5ba94e794a8e59cbae699afefbc8ce8afb7e997aee6808ee4b988e4bfaee694b9efbc9f\" rel=\"noopener\" class=\"external-link\" href=\"https://help.upyun.com/knowledge-base/%e6%8e%a7%e5%88%b6%e5%8f%b0%e6%9c%8d%e5%8a%a1%e9%85%8d%e7%bd%ae/#1-e68891e683b3e4bfaee694b9e5ba94e794a8e59cbae699afefbc8ce8afb7e997aee6808ee4b988e4bfaee694b9efbc9f\" target=\"_blank\">又拍云的文档</a>目前应用场景只是一个标示, 功能是一样的, 随便选也行. 创建完成后又拍云会给出一个CNAME域名, 在域名域名解析中为域名创建一个CNAME记录, 记录值是又拍云会给出的这个CNAME域名.</p>\n<div><figure class=\"post__image\"><img loading=\"lazy\"  src=\"https://blog.merack.top/media/posts/8/1717757460.png\" alt=\"\" width=\"1228\" height=\"292\" sizes=\"(max-width: 1920px) 100vw, 1920px\" srcset=\"https://blog.merack.top/media/posts/8/responsive/1717757460-xs.png 640w ,https://blog.merack.top/media/posts/8/responsive/1717757460-sm.png 768w ,https://blog.merack.top/media/posts/8/responsive/1717757460-md.png 1024w ,https://blog.merack.top/media/posts/8/responsive/1717757460-lg.png 1366w ,https://blog.merack.top/media/posts/8/responsive/1717757460-xl.png 1600w ,https://blog.merack.top/media/posts/8/responsive/1717757460-2xl.png 1920w\"></figure></div>\n<p>回源协议选协议跟随,源站证书校验我这里没开, 源站地址根据<a data-tooltip-position=\"top\" aria-label=\"https://docs.github.com/zh/pages/configuring-a-custom-domain-for-your-github-pages-site/managing-a-custom-domain-for-your-github-pages-site#configuring-an-apex-domain\" rel=\"noopener\" class=\"external-link\" href=\"https://docs.github.com/zh/pages/configuring-a-custom-domain-for-your-github-pages-site/managing-a-custom-domain-for-your-github-pages-site#configuring-an-apex-domain\" target=\"_blank\">GitHub Pages的文档</a>填以下IP(建议配置的时候去文档里找, 防止GitHub那边更新IP), 然后点击确定创建服务.</p>\n<p><code>185.199.108.153<br>185.199.109.153<br>185.199.110.153<br>185.199.111.153</code></p>\n<figure class=\"post__image\"><img  src=\"https://blog.merack.top/media/posts/8/1717758315.png\" alt=\"\" width=\"944\" height=\"426\" sizes=\"(max-width: 1920px) 100vw, 1920px\" srcset=\"https://blog.merack.top/media/posts/8/responsive/1717758315-xs.png 640w ,https://blog.merack.top/media/posts/8/responsive/1717758315-sm.png 768w ,https://blog.merack.top/media/posts/8/responsive/1717758315-md.png 1024w ,https://blog.merack.top/media/posts/8/responsive/1717758315-lg.png 1366w ,https://blog.merack.top/media/posts/8/responsive/1717758315-xl.png 1600w ,https://blog.merack.top/media/posts/8/responsive/1717758315-2xl.png 1920w\"></figure><br><figure class=\"post__image\"><img loading=\"lazy\"  src=\"https://blog.merack.top/media/posts/8/1717757656.png\" alt=\"\" width=\"824\" height=\"545\" sizes=\"(max-width: 1920px) 100vw, 1920px\" srcset=\"https://blog.merack.top/media/posts/8/responsive/1717757656-xs.png 640w ,https://blog.merack.top/media/posts/8/responsive/1717757656-sm.png 768w ,https://blog.merack.top/media/posts/8/responsive/1717757656-md.png 1024w ,https://blog.merack.top/media/posts/8/responsive/1717757656-lg.png 1366w ,https://blog.merack.top/media/posts/8/responsive/1717757656-xl.png 1600w ,https://blog.merack.top/media/posts/8/responsive/1717757656-2xl.png 1920w\"></figure>\n<h4>CDN功能设置</h4>\n<p>接着进入到CDN功能配置.</p>\n<h5>回源管理</h5>\n<p>在回源管理中回源Host中填入你自己的自定义域名,  比如我这里是blog.merack.top, 因为源站设置中的IP托管了成千上万个GitHub Pages, 需要回源Host中的域名才能找到你的.</p>\n<figure class=\"post__image\"><img loading=\"lazy\"  src=\"https://blog.merack.top/media/posts/8/1717760653.png\" alt=\"\" width=\"1280\" height=\"271\" sizes=\"(max-width: 1920px) 100vw, 1920px\" srcset=\"https://blog.merack.top/media/posts/8/responsive/1717760653-xs.png 640w ,https://blog.merack.top/media/posts/8/responsive/1717760653-sm.png 768w ,https://blog.merack.top/media/posts/8/responsive/1717760653-md.png 1024w ,https://blog.merack.top/media/posts/8/responsive/1717760653-lg.png 1366w ,https://blog.merack.top/media/posts/8/responsive/1717760653-xl.png 1600w ,https://blog.merack.top/media/posts/8/responsive/1717760653-2xl.png 1920w\"></figure>\n<p><strong>注意!!!</strong>: 如果你在上面的步骤中已经为GitHub仓库配置了自定义域名, 这里的回源Host填上的就是该域名, 而不是xxx.github.io, 否则会造成too many redirects 的错误.</p>\n<h5>验证</h5>\n<p>到这里就可以就可以验证是否配置成功了, 直接ping 或者dig我们的域名, 如果返回的是nm.aicdn.com, 那么就表示我们成功解析到了CDN,访问网站检查是否有其他问题</p>\n<figure class=\"post__image\"><img loading=\"lazy\"  src=\"https://blog.merack.top/media/posts/8/1717761171.png\" alt=\"\" width=\"576\" height=\"252\" sizes=\"(max-width: 1920px) 100vw, 1920px\" srcset=\"https://blog.merack.top/media/posts/8/responsive/1717761171-xs.png 640w ,https://blog.merack.top/media/posts/8/responsive/1717761171-sm.png 768w ,https://blog.merack.top/media/posts/8/responsive/1717761171-md.png 1024w ,https://blog.merack.top/media/posts/8/responsive/1717761171-lg.png 1366w ,https://blog.merack.top/media/posts/8/responsive/1717761171-xl.png 1600w ,https://blog.merack.top/media/posts/8/responsive/1717761171-2xl.png 1920w\"></figure>\n<p>更进一步, 可以使用一些在线ping网站来检测CDN是否根据不同地区就近返回: <a href=\"https://www.itdog.cn/ping\">https://www.itdog.cn/ping</a></p>\n<h5>HTTPS</h5>\n<p>此外强烈建议配置下https, 又拍云申购SSL证书中选择Let's Encrypt是免费的, 又拍云会自动帮你续期.</p>\n<h5>其他配置与注意事项</h5>\n<ol>\n<li>其他的配置按需求点点就行, 需要注意的是我看到一些资料说HTTP 302 调度这个功能可能会造成一些问题, 建议不开这个. </li>\n<li>如果要开源站资源迁移这个功能, 需要配合缓存配置中将资源缓存时间配置为24小时以上才会触发迁移. 如果要验证缓存时间可以通过浏览器的开发者工具检查响应头的Cache-Control字段, 具体可以看<a href=\"https://docs.upyun.com/cdn/guide/#_6\">又拍云的这个文档</a> (https://docs.upyun.com/cdn/guide/#_6). 不过, 除非你了解<a href=\"https://help.upyun.com/knowledge-base/cdn-source-resource-move/\">源站资源迁移的访问机制</a> (https://help.upyun.com/knowledge-base/cdn-source-resource-move/), 否则不建议开启, 会对资源更新造成一些问题.</li>\n<li>如果你的域名挂靠在Cloudflare, 请勿给根域名(即不带任何前缀, 主机记录为@的那个域名 )做CNAME解析(例如, 不能为merack.top添加又拍云的CNAME记录), 因为根据<a href=\"https://datatracker.ietf.org/doc/html/rfc1912\">RFC1912</a>，域名根域名不得存在 CNAME 记录，根域名的 CNAME 记录会与域名的 MX 邮箱记录、TXT 域名验证记录发生冲突, Cloudflare会将该CNAME记录展平(<a href=\"https://developers.cloudflare.com/dns/cname-flattening/\">CNAME flattening</a>), 指向的是又拍云在国外的某个节点, 无论国内国外访问都是请求的这个节点的资源, 那么这就失去了CDN的功能.<br><figure class=\"alignnone size-full wp-image-40\"><img loading=\"lazy\"  src=\"https://cdn.merack.top/wp-content/uploads/2024/06/screenshot_2024_0605_11-58-14.png\" alt=\"\" width=\"1238\" height=\"150\" data-is-external-image=\"true\"></figure></li>\n</ol>\n<h2>结语</h2>\n<p>到此又拍云CDN加速GitHub Pages就配置完成了, 本文只是我配置时的一些简要记录, 仅供参考. 如果遇到问题可以通过邮件与我交流. 像其他的一些静态网站加速, 例如GitLab, Vercel, Netlify, Cloudflare Pages, 思路应该也大致相同, 但还是要根据不同平台调整.</p>",
            "author": {
                "name": "Merack"
            },
            "tags": [
            ],
            "date_published": "2024-06-07T20:56:06+08:00",
            "date_modified": "2024-09-22T11:57:44+08:00"
        }
    ]
}
