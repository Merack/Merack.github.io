<!DOCTYPE html><html lang="en-gb"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>用Flutter开发的一款基于随机奖励机制的专注学习app - Merack&#x27;s Home</title><meta name="description" content="灵感来源于之前看到的一个B站视频: BV1naLozQEBq , 觉得挺有意思的, 联想到很久之前学的Flutter也没有怎么练习过, 于是本着复习Flutter的想法断断续续捣鼓出的一个玩具. 原理引用下GitHub上JokerQianwei/Focus 项目的README: 还可以在这个链接了解: https://www.yuque.com/u43692620/yyl2g7/fup4ss9g56olg3gy&hellip;"><meta name="generator" content="Publii Open-Source CMS for Static Site"><link rel="canonical" href="https://blog.merack.top/yong-flutterkai-fa-de-yi-kuan-ji-yu-sui-ji-jiang-li-ji-zhi-de-zhuan-zhu-xue-xi-app.html"><link rel="alternate" type="application/atom+xml" href="https://blog.merack.top/feed.xml" title="Merack&#x27;s Home - RSS"><link rel="alternate" type="application/json" href="https://blog.merack.top/feed.json" title="Merack&#x27;s Home - JSON"><link rel="shortcut icon" href="https://blog.merack.top/media/website/favicon-16x16.png" type="image/png"><link rel="stylesheet" href="https://blog.merack.top/assets/css/style.css"><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.merack.top/yong-flutterkai-fa-de-yi-kuan-ji-yu-sui-ji-jiang-li-ji-zhi-de-zhuan-zhu-xue-xi-app.html"},"headline":"用Flutter开发的一款基于随机奖励机制的专注学习app","datePublished":"2025-05-18T19:14+08:00","dateModified":"2025-06-08T19:23+08:00","description":"灵感来源于之前看到的一个B站视频: BV1naLozQEBq , 觉得挺有意思的, 联想到很久之前学的Flutter也没有怎么练习过, 于是本着复习Flutter的想法断断续续捣鼓出的一个玩具. 原理引用下GitHub上JokerQianwei/Focus 项目的README: 还可以在这个链接了解: https://www.yuque.com/u43692620/yyl2g7/fup4ss9g56olg3gy&hellip;","author":{"@type":"Person","name":"Merack","url":"https://blog.merack.top/authors/merack/"},"publisher":{"@type":"Organization","name":"Merack"}}</script><noscript><style>img[loading] {
                    opacity: 1;
                }</style></noscript></head><body class="post-template"><header class="top js-header"><a class="logo" href="https://blog.merack.top/">Merack&#x27;s Home</a><nav class="navbar js-navbar"><button class="navbar__toggle js-toggle" aria-label="Menu" aria-haspopup="true" aria-expanded="false"><span class="navbar__toggle-box"><span class="navbar__toggle-inner">Menu</span></span></button><ul class="navbar__menu"><li><a href="https://blog.merack.top/about.html" target="_self">About</a></li></ul></nav></header><main class="post"><article class="content"><div class="hero hero--noimage"><header class="hero__content"><div class="wrapper"><h1>用Flutter开发的一款基于随机奖励机制的专注学习app</h1><div class="feed__meta content__meta"><img src="https://blog.merack.top/media/website/qbanjinmuyan_Kan-Tu-Wang.web-2.png" loading="eager" height="500" width="458" class="feed__author-thumb" alt="Merack"> <a href="https://blog.merack.top/authors/merack/" class="feed__author">Merack</a> <time datetime="2025-05-18T19:14" class="feed__date">May 18, 2025</time></div></div></header></div><div class="entry-wrapper content__entry"><p>灵感来源于之前看到的一个B站视频: <a href="https://www.bilibili.com/video/BV1naLozQEBq" rel="nofollow">BV1naLozQEBq</a>  , 觉得挺有意思的, 联想到很久之前学的Flutter也没有怎么练习过, 于是本着复习Flutter的想法断断续续捣鼓出的一个玩具.</p><h2>机制简单介绍</h2><ol><li>有一个专注时间和休息时间, 专注时间一到就开始进入休息时间, 休息时间结束完成一个周期</li><li>定义一个区间, 每次生成一个在这个区间的随机秒数, 每经过这么多秒就在专注时间内插入一个微休息, 微休息时间很短大概是10s</li><li>微休息单独计时, 不影响主专注时间的计时且只发生在专注阶段</li></ol><p>原理引用下GitHub上<a href="https://github.com/JokerQianwei/Focus/">JokerQianwei/Focus</a>  项目的README:</p><blockquote><strong>间隔效应 (Gap Effects)</strong>：神经科学家 Andrew Huberman 教授指出，学习过程中短暂的、几秒钟的停顿，可以触发大脑神经元的快速回顾机制，有效提升学习和记忆效率。Random Focus 的随机提示音和小憩功能正是基于此原理，引导用户利用碎片化的时间进行高效的信息巩固。（参考：Huberman Lab 播客 - <a href="https://www.bilibili.com/video/BV1BopsenEaW/?share_source=copy_web&amp;vd_source=80067a9d068c4c06488f9be7364e3539" rel="nofollow">像天才一样学习</a>，1:22:03 处）</blockquote><blockquote><strong>随机奖励 (Random Rewards)</strong>：心理学研究表明，不可预测的随机奖励比固定奖励更能激发持续的行为动力。本应用中的随机提示音，在提醒休息的同时，也扮演了积极反馈的角色，帮助用户克服长时间专注带来的疲惫感，保持学习或工作的动力。（灵感来源：<a href="https://www.bilibili.com/video/BV1naLozQEBq/?share_source=copy_web&amp;vd_source=80067a9d068c4c06488f9be7364e3539" rel="nofollow">为什么我能每天学习10小时</a>）</blockquote><p>还可以在这个链接了解: <a href="https://www.yuque.com/u43692620/yyl2g7/fup4ss9g56olg3gy">https://www.yuque.com/u43692620/yyl2g7/fup4ss9g56olg3gy</a></p><h2>成品展示</h2><figure class="alignnone size-full wp-image-197">下载地址(仅安卓): <a href="https://pan.quark.cn/s/db7160d17739">https://pan.quark.cn/s/db7160d17739</a>  提取码：TnbS 更新: <a href="https://github.com/Merack/time_machine/releases">https://github.com/Merack/time_machine/releases</a> <a href="https://cdn.merack.top/wp-content/uploads/2025/06/38e2bd2c-e475-69bb-bb42-2a92311a71b9.jpeg"><img src="https://cdn.merack.top/wp-content/uploads/2025/06/38e2bd2c-e475-69bb-bb42-2a92311a71b9.jpeg" alt="" width="729" height="500" data-is-external-image="true"></a></figure><a href="https://cdn.merack.top/wp-content/uploads/2025/06/0cefa0c1-7433-b6a7-66e2-49f26440243b.jpeg"><figure class="alignnone size-full wp-image-198"><img loading="lazy" src="https://cdn.merack.top/wp-content/uploads/2025/06/0cefa0c1-7433-b6a7-66e2-49f26440243b.jpeg" alt="" width="709" height="500" data-is-external-image="true"></figure></a><p></p><h2>代码设计</h2><h3>总体思路</h3><p>Dart 里的<code>Timer</code>类正好提供了来做倒计时的方法<code>periodic</code>, 函数签名: <code>factory Timer.periodic(Duration duration, void callback(Timer timer))</code>. 实际上它的作用是每隔一个<code>duration</code>周期执行一次回调方法<code>callback</code>, 那么我们就可以让这个周期为1s, 用变量存储需要倒计时的秒数, 在callback里一直让这个变量做-1操作, 直到为0就可以了.核心逻辑如下:</p><pre class="EnlighterJSRAW" data-enlighter-language="generic">void _startFocusCountdown() {
    _timer = Timer.periodic(const Duration(seconds: 1), (timer) {
      if (remainingFocusTime &gt; 0) {
        remainingFocusTime--;
      } else {
        _handleFocusTimerComplete();
      }
    });
  }</pre><p>由于专注和微休息是单独计时, 所以创建两个Timer来计时, 一个用作专注与休息, 一个用作微休息的到来的倒计时与微休息期间的倒计时.</p><h3>状态维护</h3><p>为了让应用知道现在处于什么阶段了, 我们还需要维护当前的状态信息. 目前是设计了5个状态: 专注状态, 大休息状态, 微休息状态, 暂停状态, 停止状态. 用了一个枚举类来保存, 同时<code>isRunning</code>变量用来标识当前专注计时器是否处于运行状态</p><pre class="EnlighterJSRAW" data-enlighter-language="generic">enum TimerStatus {
  focus,      // 专注状态
  microBreak, // 微休息状态
  bigBreak,   // 大休息状态
  paused,     // 暂停状态
  stopped     // 停止状态
}

// 是否正在运行
var isRunning = false</pre><h3>状态切换</h3><p>在当前状态计时结束后要进入下一个阶段, 执行相关操作, 因此定义了一系列操作方法. <strong>1.重置</strong></p><pre class="EnlighterJSRAW" data-enlighter-language="generic">void resetTimer() {
   // 停止两个计时器
    _timer?.cancel();
    _microBreakTimer?.cancel();
    // 状态更新为停止
    timerStatus = TimerStatus.stopped;
    // 重置剩余时间和总时间
    remainingFocusTime = state.focusTimeSeconds;
    totalTime = state.focusTimeSeconds;
    // 更新运行状态
    isRunning = false;
    // 生成下一个微休息时间
    generateNextMicroBreakInterval();
}</pre><p><strong>2.开始</strong></p><pre class="EnlighterJSRAW" data-enlighter-language="generic">/// 开始计时器
  void _startTimer() {
    if (timerStatus == TimerStatus.stopped) {
      // 首次启动,直接进入专注会话
      _startFocusSession();
    } else {
      // 从暂停状态恢复
      if (timerStatus == TimerStatus.paused) {
        // 更新 isRunning 状态
        isRunning = true;
        // 如果之前的状态是 focus 或者 microBreak, 则恢复为专注状态
        if ((previousStatus == TimerStatus.focus) ||
            (previousStatus == TimerStatus.microBreak)) {
          timerStatus = TimerStatus.focus;
        } else {
          // 恢复为之前的状态, 逻辑上这里应该只能是 bigBreak
          timerStatus = previousStatus;
        }
        // 重新开始专注计时器
        _startFocusCountdown();
        // 重新生成随机间隔
        generateNextMicroBreakInterval();
        // 重新开始微休息计时器
        _startMicroBreakCountdown();
      }
    }
  }</pre><p>3. 暂停</p><pre class="EnlighterJSRAW" data-enlighter-language="generic">/// 暂停计时器
  void _pauseTimer() {
    // 一同暂停专注和微休息
    _timer?.cancel();
    _microBreakTimer?.cancel();
    // 保存之前的状态用于恢复
    previousStatus = timerStatus;
    // 状态更新
    timerStatus = TimerStatus.paused;
    isRunning = false;
  }</pre><h4>专注计时器相关</h4><p><strong>1. 专注计时器计数逻辑, 专注计时和休息计时共用</strong></p><pre class="EnlighterJSRAW" data-enlighter-language="generic">void _startFocusCountdown() {
  _timer = Timer.periodic(const Duration(seconds: 1), (timer) {
    if (remainingFocusTime &gt; 0) {
      remainingFocusTime--;
    } else {
    // 处理专注计时器完成的函数
      _handleFocusTimerComplete();
    }
  });
}</pre><p><strong>2. 处理专注计时器完成的函数, 专注计时和休息计时共用</strong></p><pre class="EnlighterJSRAW" data-enlighter-language="generic">void _handleFocusTimerComplete() {
   _timer?.cancel();

   switch (timerStatus) {
     case TimerStatus.focus:
       _completeFocusSession();
       break;
     // 如果专注计时走完正好又处于微休息期间时, 仍然认为完成了专注任务
     case TimerStatus.microBreak:
       _completeFocusSession();
       break;
     case TimerStatus.bigBreak:
       _completeBigBreak();
       break;
     default:
       break;
   }
 }</pre><p><strong>3.开始专注会话</strong></p><pre class="EnlighterJSRAW" data-enlighter-language="generic">/// 开始专注会话
  void _startFocusSession() {
    // 初始化状态
    timerStatus = TimerStatus.focus;
    remainingFocusTime = focusTimeSeconds;
    totalTime = focusTimeSeconds;
    isRunning = true;
    generateNextMicroBreakInterval();
   // 同时开启两个计时器
    _startFocusCountdown();
    _startMicroBreakCountdown();
  }</pre><p><strong>4. 处理专注状态完成</strong></p><pre class="EnlighterJSRAW" data-enlighter-language="generic">/// 完成专注会话
  void _completeFocusSession() {
    // 不在专注时段, 微休息停止计时
    _microBreakTimer?.cancel();

    // 播放专注完成音效
    _playAudio('audio/wakeup.mp3');

    // 增加完成专注数
    state.completedCycles.value++;

    // 如果用户设置大休息时间为0, 则跳过休息阶段
    if (state.bigBreakTimeSeconds.value == 0) {
      resetTimer();
      _startFocusSession();
      return;
    }

    // 进入大休息状态
    state.timerStatus.value = TimerStatus.bigBreak;
    state.remainingFocusTime.value = state.bigBreakTimeSeconds.value;
    state.totalTime.value = state.bigBreakTimeSeconds.value;

    // 开始大休息倒计时
    _startFocusCountdown();
  }</pre><p><strong>5.处理休息状态完成</strong> 但休息完成时就说明一个周期完成了, 于是进入下一个周期<code>_startFocusSession()</code> 或者重置一切让计时器停止<code>resetTimer()</code>, 后期再加个flag控制这个行为吧</p><pre class="EnlighterJSRAW" data-enlighter-language="generic">/// 完成大休息
  void _completeBigBreak() {
    // 播放大休息结束音效
    _playAudio('audio/alarm-wood.mp3');
    // 完成了一个周期, 开始新的专注会话
    // _startFocusSession();
    // 重置计数器
    resetTimer();
  }</pre><h4>微休息计时器相关</h4><p>微休息会话的开启其实是由前面的开始专注会话<code>_startFocusSession()</code>里随专注计时器一同开启的, 因此微休息这里只要处理微休息计数器逻辑和微休息状态完成的逻辑就可以了. 但是微休息来临计时的完成和微休息的完成都没有像专注和大休息一样分开写相应的complete函数, 而是都把complete的逻辑分散到<code>_startMicroBreakCountdown</code> 和<code>_handleMicroBreakStatus</code>里了, 所以这部分看起来有点屎山, 后面有空再优化 1.处理微休息到来间隔计时和微休息期间计时</p><pre class="EnlighterJSRAW" data-enlighter-language="generic">void _startMicroBreakCountdown() {
    // 检查微休息是否启用
    if (!microBreakEnabled) {
      return;
    }

    // 如果微休息时间设置为0也不启用微休息
    if (microBreakTimeSeconds == 0) {
      return;
    }
    // 处理微休息到来时间倒计时
    if (timerStatus == TimerStatus.focus) {
      _microBreakTimer = Timer.periodic(const Duration(seconds: 1), (timer) {
        if (nextMicroBreakTime &gt; 0) {
          nextMicroBreakTime--;
        } else {
        // 处理微休息计数器计时完成逻辑
          _handleMicroBreakStatus(isStartMicroBreak: true);
        }
      });
    }
    // 处理微休息期间倒计时
    if (timerStatus == TimerStatus.microBreak) {
      _microBreakTimer = Timer.periodic(const Duration(seconds: 1), (timer) {
        if (remainingMicroBreakTime &gt; 0) {
          remainingMicroBreakTime--;
        } else {
          _handleMicroBreakStatus(isStartMicroBreak: false);
        }
      });
    }
  }</pre><p>2. 处理微休息计数器计时完成逻辑</p><pre class="EnlighterJSRAW" data-enlighter-language="generic">void _handleMicroBreakStatus({required bool isStartMicroBreak}) {
    // 开始微休息
    if (isStartMicroBreak) {
      _microBreakTimer?.cancel();

      // 播放微休息开始音效
      _playAudio('audio/drop.mp3');

      // 进入微休息状态
      timerStatus = TimerStatus.microBreak;

      // 开始微休息倒计时
      // 设置微休息时间
      remainingMicroBreakTime = microBreakTimeSeconds;
      _startMicroBreakCountdown();
    } else {
      // 微休息结束
      _microBreakTimer?.cancel();

      // 播放微休息结束音效
      _playAudio('audio/ding.mp3');

      // 更新状态
      timerStatus = TimerStatus.focus;

      generateNextMicroBreakInterval();
      // 开始微休息倒计时
      _startMicroBreakCountdown();
    }
  }</pre><p>代码都是随想随写没什么技术含量, 包含界面部分的完整代码等后面再整理整理好就开源出来吧~ 更新: 已开源: <a href="https://github.com/Merack/time_machine">https://github.com/Merack/time_machine</a></p><h2>后续计划</h2><ul><li>数据统计</li><li>自动开始控制</li><li>自定义进度条颜色</li><li>暗色模式</li><li>禅模式</li><li>开关提示音</li><li>后台保活(尽量...)</li><li>多语言--英文</li></ul><h2>后记</h2><p>Flutter是跨平台的框架, 但是我只有安卓设备于是只做了安卓的. 而且也只是验证想法的练手作品也别指望它能有多好用, 我只是个菜鸡安卓杀后台的问题解决不了一点~ Flutter的声明式UI写界面确实比安卓原生开发用xml那套方便许多, 但页面元素一多起来层层嵌套也是很折磨人, 经常找括号和逗号要找半天. 体验下来觉得写UI还得是web三件套,怪不得Electron和Tauri这类的框架能这么流行. 那在移动端最接近web的应该是react native了吧, 听说JSI和新架构让rn性能有了不错的提升, 有机会再试试吧, 顺便捡一下学了但从没用过的react. 还有一点就是感觉Flutter有点太依赖生态了, 一些系统调用的功能如果没有相应的包那就得自己写FFI, rn应该也差不多, 不是原生的框架应该都这样吧~</p></div><footer class="content__footer"><div class="entry-wrapper"><div class="content__actions"></div></div><nav class="content__nav"><div class="wrapper"><div class="content__nav-inner"><div class="content__nav-prev"><a href="https://blog.merack.top/rustxue-xi-bi-ji-rustzhong-de-box-rc-he-refcell.html" class="content__nav-link" rel="prev"><div><span>Previous</span> Rust学习笔记: Rust中的Box, Rc 和 RefCell</div></a></div><div class="content__nav-next"><a href="https://blog.merack.top/shelljiao-ben-linuxding-shi-bei-fen-bing-tong-guo-webdavshang-chuan-zhi-jian-guo-yun.html" class="content__nav-link" rel="next"><div><span>Next</span> shell脚本 - Linux定时备份并通过WebDAV上传至坚果云</div></a></div></div></div></nav></footer></article></main><footer class="footer"><div class="wrapper"><div class="footer__copyright"><p>Powered by Publii</p><div style="flex; align-items: center; justify-content: center;"><a href="https://cloudflare.com/"><img src="https://cdn.merack.top/wp-content/uploads/2024/12/ae2e8d68-158b-1842-fc34-0ebcc1365d6c.png" alt="cloudflare"> </a><a href="https://www.upyun.com/?utm_source=lianmeng&amp;utm_medium=referral"><img style="margin-right: 1px; vertical-align: middle;" src="https://cdn.merack.top/wp-content/uploads/2024/12/8a9de8d6-7a3c-e553-b074-cf653f15d712.png" alt="upyun"> </a><a href="https://cloudflare.com/">提供CDN服务</a></div></div><button onclick="backToTopFunction()" id="backToTop" class="footer__bttop" aria-label="Back to top" title="Back to top"><svg width="20" height="20"><use xlink:href="https://blog.merack.top/assets/svg/svg-map.svg#toparrow"/></svg></button></div></footer><script defer="defer" src="https://blog.merack.top/assets/js/scripts.min.js"></script><script>window.publiiThemeMenuConfig={mobileMenuMode:'overlay',animationSpeed:300,submenuWidth: 'auto',doubleClickTime:500,mobileMenuExpandableSubmenus:true,relatedContainerForOverlayMenuSelector:'.top'};</script><script>var images = document.querySelectorAll('img[loading]');
        for (var i = 0; i < images.length; i++) {
            if (images[i].complete) {
                images[i].classList.add('is-loaded');
            } else {
                images[i].addEventListener('load', function () {
                    this.classList.add('is-loaded');
                }, false);
            }
        }</script></body></html>